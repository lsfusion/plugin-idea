
{
  parserClass="com.simpleplugin.parser.LSFParser"
  parserUtilClass="com.simpleplugin.parser.GeneratedParserUtilBase"
  stubParserClass="com.simpleplugin.parser.GeneratedParserUtilBase"
 
  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"
 
  psiClassPrefix="LSF"
  psiImplClassSuffix="Impl"
  psiPackage="com.simpleplugin.psi"
  psiImplPackage="com.simpleplugin.psi.impl"
 
  elementTypeHolderClass="com.simpleplugin.psi.LSFTypes"
  elementTypeClass="com.simpleplugin.psi.LSFElementType"
  tokenTypeClass="com.simpleplugin.psi.LSFTokenType"
}

script ::= moduleHeader (scriptStatement*)
private scriptStatement ::= statement { recoverUntil = "script_statement_recover" }
private script_statement_recover ::= !def_statement_recover_start 

simpleName ::= ID
{
    mixin="com.simpleplugin.psi.LSFIdImpl"
    implements="com.simpleplugin.psi.LSFId"
}

moduleName ::= simpleName;
requireList ::= REQUIRE nonEmptyModuleUsageList SEMI;
priorityList ::= PRIORITY nonEmptyNamespaceUsageList SEMI;
namespaceName ::= NAMESPACE namespaceUsage SEMI {
    mixin="com.simpleplugin.psi.declarations.impl.LSFExplicitNamespaceDeclarationImpl" implements="com.simpleplugin.psi.declarations.LSFExplicitNamespaceDeclaration"
    stubClass = "com.simpleplugin.psi.stubs.ExplicitNamespaceStubElement"
    elementTypeFactory = "com.simpleplugin.psi.stubs.types.LSFStubFactory.create"
}
moduleHeader ::= MODULE moduleName SEMI
                 requireList?
                 priorityList?
                 namespaceName?
{mixin="com.simpleplugin.psi.declarations.impl.LSFModuleDeclarationImpl" implements="com.simpleplugin.psi.declarations.LSFModuleDeclaration"
    stubClass = "com.simpleplugin.psi.stubs.ModuleStubElement"
    elementTypeFactory = "com.simpleplugin.psi.stubs.types.LSFStubFactory.create"
    recoverUntil = "script_statement_recover"
}

// fake rules to generate types
fake_comments ::= COMMENTS
//fake_whitespaces ::= WHITESPACES

private statement ::=   classStatement
                    |	extendClassStatement
                    |	groupStatement
                    |	overrideStatement // starts with ID
                    |	constraintStatement
                    |	followsStatement // starts with ID
                    |	writeWhenStatement // starts with ID
                    |	propertyStatement // important to eat ID
                    |	eventStatement
                    |   showDepStatement
                    |	globalEventStatement
                    |	aspectStatement
                    |	tableStatement
                    |	loggableStatement
                    |	indexStatement
                    |	formStatement
                    |	designStatement
                    |	windowStatement
                    |	navigatorStatement
                    |	metaCodeStatement // ?
                    |	metaCodeDeclarationStatement // ?
                    |	emptyStatement
// Important ! after recover the rule should mandatory be pinned (matched)
private def_statement_recover_start ::= AFTER | BEFORE | (((CLASS (ABSTRACT | NATIVE)?) | ATSIGN | FORM | GROUP | META | TABLE | (WINDOW windowType))? ID) | CONSTRAINT | DESIGN | (EXTEND (CLASS | FORM | DESIGN)) | HIDE | INDEX | LOGGABLE | NAVIGATOR | ON | SEMI | SHOWDEP | WHEN

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////// CLASS STATEMENT /////////////////////////////
////////////////////////////////////////////////////////////////////////////////

classStatement ::= CLASS (ABSTRACT | NATIVE)? simpleNameWithCaption classInstancesAndParents { pin=3
    mixin = "com.simpleplugin.psi.declarations.impl.LSFClassDeclarationImpl" implements = "com.simpleplugin.psi.declarations.LSFClassDeclaration"
    stubClass = "com.simpleplugin.psi.stubs.ClassStubElement"
    elementTypeFactory = "com.simpleplugin.psi.stubs.types.LSFStubFactory.create"
}

extendClassStatement ::= EXTEND CLASS customClassUsage classInstancesAndParents {pin=2}

private classInstancesAndParents ::=    LBRACE simpleNameWithCaptionList RBRACE (classParentsList SEMI)?
		                            |   (classParentsList)? SEMI

classParentsList ::= COLON nonEmptyCustomClassUsageList

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////// GROUP STATEMENT /////////////////////////////
////////////////////////////////////////////////////////////////////////////////

groupStatement ::= GROUP simpleNameWithCaption (COLON groupUsage)? SEMI
{mixin="com.simpleplugin.psi.declarations.impl.LSFGroupDeclarationImpl" implements="com.simpleplugin.psi.declarations.LSFGroupDeclaration"
    stubClass = "com.simpleplugin.psi.stubs.GroupStubElement"
    elementTypeFactory = "com.simpleplugin.psi.stubs.types.LSFStubFactory.create"
    pin = 2
}


////////////////////////////////////////////////////////////////////////////////
//////////////////////////////// PROPERTY STATEMENT ////////////////////////////
////////////////////////////////////////////////////////////////////////////////

propertyStatement ::= propertyDeclaration EQUAL
                      (expressionUnfriendlyPD | propertyExpression | NATIVE)
                      propertyOptions
                      (SEMI)?
{mixin="com.simpleplugin.psi.declarations.impl.LSFGlobalPropDeclarationImpl" implements="com.simpleplugin.psi.declarations.LSFGlobalPropDeclaration"
    stubClass = "com.simpleplugin.psi.stubs.PropStubElement"
    elementTypeFactory = "com.simpleplugin.psi.stubs.types.LSFStubFactory.create"
    pin = 1
}

propertyDeclaration ::= simpleNameWithCaption (LBRAC paramDeclareList RBRAC)?

paramDeclare ::= ID
paramDeclareList ::= (nonEmptyParamDeclareList)?
nonEmptyParamDeclareList ::= paramDeclare (COMMA paramDeclare)*


propertyExpression ::= ifPE;

ifPE ::= orPE (IF orPE)*
orPE ::= xorPE (OR xorPE)*
xorPE ::= andPE (XOR andPE)*
andPE ::= notPE (AND notPE)*
notPE ::= (NOT notPE) | equalityPE;

equalityPE ::= relationalPE (EQ_OPERAND relationalPE)?
relationalPE ::= additiveORPE ((REL_OPERAND additiveORPE) | typePropertyDefinition)?
additiveORPE ::= additivePE (ADDOR_OPERAND additivePE)*
additivePE ::= multiplicativePE ((PLUS | MINUS) multiplicativePE)*
multiplicativePE ::= unaryMinusPE (MULT_OPERAND unaryMinusPE)*
unaryMinusPE ::= (MINUS unaryMinusPE) | postfixUnaryPE;
postfixUnaryPE ::= simplePE (LSQBR LEX_UINT_LITERAL RSQBR)?
simplePE ::= (LBRAC propertyExpression RBRAC) | expressionPrimitive
expressionPrimitive ::= expressionFriendlyPD | singleParameterUsage;
singleParameterUsage ::= parameterUsage

expressionFriendlyPD ::= joinPropertyDefinition
	    |	multiPropertyDefinition
	    |	overridePropertyDefinition
	    |	ifElsePropertyDefinition
	    |	maxPropertyDefinition
	    |	casePropertyDefinition
	    |	partitionPropertyDefinition
	    |	recursivePropertyDefinition
	    |	structCreationPropertyDefinition
	    |	concatPropertyDefinition
	    |	castPropertyDefinition
	    |	sessionPropertyDefinition
	    |	signaturePropertyDefinition
	    |	literal

expressionUnfriendlyPD ::= contextIndependentPD | actionPropertyDefinition

contextIndependentPD ::= dataPropertyDefinition
	                |   abstractActionPropertyDefinition
                    |   abstractPropertyDefinition
	                |   formulaPropertyDefinition
	                |   groupPropertyDefinition
                    |   filterPropertyDefinition

joinPropertyDefinition ::= JOIN? propertyObject LBRAC propertyExpressionList RBRAC

overridePropertyDefinition ::= (OVERRIDE | EXCLUSIVE) nonEmptyPropertyExpressionList

ifElsePropertyDefinition ::= IF propertyExpression
                                    THEN propertyExpression
                                    (ELSE propertyExpression)?   // check greedy

maxPropertyDefinition ::= (MAX | MIN) nonEmptyPropertyExpressionList

caseBranchBody ::= WHEN propertyExpression THEN propertyExpression
casePropertyDefinition ::= CASE (exclusiveOverrideOption)?
                           (caseBranchBody)+
                           (ELSE propertyExpression)?

multiPropertyDefinition ::= MULTI nonEmptyPropertyExpressionList (exclusiveOverrideOption)?

partitionPropertyDefinition ::= PARTITION
                                (   (SUM | PREV)
                                |   UNGROUP propertyObject
                                    (   PROPORTION (STRICT)? ROUND LBRAC LEX_UINT_LITERAL RBRAC
                                    |   LIMIT (STRICT)?
                                    )
                                )
                                propertyExpression (BY nonEmptyPropertyExpressionList)?
                                (ORDER (DESC )? nonEmptyPropertyExpressionList)?
                                (WINDOW EXCEPTLAST)?

recursivePropertyDefinition ::= RECURSION propertyExpression STEP propertyExpression (CYCLES (YES |	NO | IMPOSSIBLE))?

structCreationPropertyDefinition ::= STRUCT LBRAC nonEmptyPropertyExpressionList RBRAC

castPropertyDefinition ::= PRIMITIVE_TYPE LBRAC propertyExpression RBRAC

concatPropertyDefinition ::= CONCAT stringLiteral COMMA nonEmptyPropertyExpressionList

sessionPropertyDefinition ::= (PREV | CHANGED | SET | DROPPED | SETCHANGED | DROPCHANGED | DROPSET) LBRAC propertyExpression RBRAC

signaturePropertyDefinition ::= (CLASS) LBRAC propertyExpression RBRAC

propertyObject ::=  propertyUsage
	            |   (LSQBR (propertyExpression | expressionUnfriendlyPD) RSQBR)



dataPropertyDefinition ::= DATA (SESSION)? className LBRAC classNameList RBRAC

abstractPropertyDefinition ::= ABSTRACT (((CASE | MULTI) (OVERRIDE | EXCLUSIVE)?) | OVERRIDE | EXCLUSIVE)? (CHECKED)? className LBRAC classNameList RBRAC

formulaPropertyDefinition ::= FORMULA (builtInClassName)? stringLiteral

groupingType ::= SUM | MAX | MIN | CONCAT | AGGR | EQUAL | LAST
groupPropertyDefinition ::= GROUP groupingType
		                    nonEmptyPropertyExpressionList
		                    (BY nonEmptyPropertyExpressionList)?
		                    (ORDER (DESC)? nonEmptyPropertyExpressionList)?
		                    (WHERE propertyExpression)?

filterPropertyDefinition ::= (FILTER | ORDER | VIEW) groupObjectID

typePropertyDefinition ::= (IS | AS) className


propertyOptions ::= (   IN groupUsage
                    |	PERSISTENT
                    |   COMPLEX
                    |	TABLE tableUsage
                    |	shortcutSetting
                    |	asEditActionSetting
                    |	toolbarSetting
                    |	fixedCharWidthSetting
                    |	minCharWidthSetting
                    |	maxCharWidthSetting
                    |	prefCharWidthSetting
                    |	imageSetting
                    |	editKeySetting
                    |	autosetSetting
                    |	confirmSetting
                    |	regexpSetting
                    |	loggableSetting
                    |	echoSymbolsSetting
                    |	indexSetting
                    |	aggPropSetting
                    |	notNullSetting
                    |	onEditEventSetting
                    |	eventIdSetting
                    )*

shortcutSetting ::= SHORTCUT propertyUsage
asEditActionSetting ::= (ASONCHANGE | ASONCHANGEWYS | ASONEDIT) propertyUsage
toolbarSetting ::= TOOLBAR
fixedCharWidthSetting ::= FIXEDCHARWIDTH intLiteral
minCharWidthSetting ::= MINCHARWIDTH intLiteral
maxCharWidthSetting ::= MAXCHARWIDTH intLiteral
prefCharWidthSetting ::= PREFCHARWIDTH intLiteral
imageSetting ::= IMAGE stringLiteral
editKeySetting ::= EDITKEY stringLiteral (SHOW | HIDE)?
autosetSetting ::= AUTOSET
confirmSetting ::= CONFIRM
regexpSetting ::= REGEXP stringLiteral (stringLiteral)?
loggableSetting ::= LOGGABLE
echoSymbolsSetting ::= ECHO
indexSetting ::= INDEXED
aggPropSetting ::= AGGPROP
notNullSetting ::= NOT nullOption (DELETE)? baseEvent
onEditEventSetting ::= ON (CHANGE | CHANGEWYS | EDIT) actionPropertyDefinitionBody
eventIdSetting ::= EVENTID stringLiteral

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////// ACTION PROPERTIES ///////////////////////////
////////////////////////////////////////////////////////////////////////////////

actionPropertyDefinition ::= ACTION
		                    (LBRAC paramDeclareList RBRAC)?
		                    actionPropertyDefinitionBody

abstractActionPropertyDefinition ::= ABSTRACT ACTION
                                    (   CASE (exclusiveOverrideOption)?
                                    |	MULTI (exclusiveOverrideOption )?
                                    |	LIST
                                    )?
                                    (CHECKED)?
                                    LBRAC classNameList RBRAC

// extendContextActionPDB comes before keepContextActionPDB to check assign action before exec action
actionPropertyDefinitionBody ::=    customActionPDB
                                |   extendContextActionPDB
                                |	keepContextActionPDB

extendContextActionPDB ::=  assignActionPropertyDefinitionBody
                        |	forActionPropertyDefinitionBody
                        |   whileActionPropertyDefinitionBody
                        |	changeClassActionPropertyDefinitionBody
                        |	deleteActionPropertyDefinitionBody
                        |	addObjectActionPropertyDefinitionBody

keepContextActionPDB ::=    listActionPropertyDefinitionBody
                        |	requestInputActionPropertyDefinitionBody
                        |	execActionPropertyDefinitionBody
                        |	ifActionPropertyDefinitionBody
                        |	caseActionPropertyDefinitionBody
                        |	multiActionPropertyDefinitionBody
                        |	terminalFlowActionPropertyDefinitionBody

customActionPDB ::= formActionPropertyDefinitionBody
                |	addFormActionPropertyDefinitionBody
                |	editFormActionPropertyDefinitionBody
                |	customActionPropertyDefinitionBody
                |   messageActionPropertyDefinitionBody
                |   asyncUpdateActionPropertyDefinitionBody
                |   seekObjectActionPropertyDefinitionBody
                |   confirmActionPropertyDefinitionBody
                |   emailActionPropertyDefinitionBody
                |	fileActionPropertyDefinitionBody
                |	evalActionPropertyDefinitionBody

formActionPropertyDefinitionBody ::=
	    FORM formUsage
		(OBJECTS formActionObjectList)?
        (CONTEXTFILTER ID EQUAL propertyExpression)?
		(formSessionScopeLiteral)?
		(modalityTypeLiteral)?
		(CHECK)? (SHOWDROP)?

formActionObjectList ::=
		ID EQUAL propertyExpression
		(COMMA ID EQUAL propertyExpression)*

customActionPropertyDefinitionBody ::= CUSTOM stringLiteral

addFormActionPropertyDefinitionBody ::= ADDFORM (SESSION)? customClassUsage
editFormActionPropertyDefinitionBody ::= EDITFORM (SESSION)? customClassUsage

addObjectActionPropertyDefinitionBody ::= ADDOBJ customClassUsage
		                                    (WHERE propertyExpression)?
		                                    (TO propertyUsage LBRAC singleParameterList RBRAC)?


emailActionPropertyDefinitionBody ::=
		EMAIL
		(FROM propertyExpression)?
		SUBJECT propertyExpression
		(emailRecipientTypeLiteral propertyExpression)*
		(	INLINE formUsage emailActionFormObjects
		|	ATTACH emailAttachFormat (NAME propertyExpression)? formUsage emailActionFormObjects
		)*

emailActionFormObjects ::=
        (   OBJECTS
			ID EQUAL propertyExpression
			(COMMA ID EQUAL propertyExpression)*
		)?
	;

confirmActionPropertyDefinitionBody ::= CONFIRM propertyExpression
messageActionPropertyDefinitionBody ::= MESSAGE propertyExpression

asyncUpdateActionPropertyDefinitionBody ::= ASYNCUPDATE propertyExpression

seekObjectActionPropertyDefinitionBody ::= SEEK groupObjectID propertyExpression

fileActionPropertyDefinitionBody ::= (LOADFILE | OPENFILE) propertyExpression

changeClassActionPropertyDefinitionBody ::= CHANGECLASS parameterUsage TO customClassUsage (WHERE propertyExpression)?
deleteActionPropertyDefinitionBody ::= DELETE parameterUsage (WHERE propertyExpression)?

evalActionPropertyDefinitionBody ::= EVAL propertyExpression

requestInputActionPropertyDefinitionBody ::= REQUEST typeId (INPUT | (ID)? actionPropertyDefinitionBody)

listActionPropertyDefinitionBody ::=    (NEWSESSION (AUTOAPPLY)? (SINGLE)?)?
		                                LBRACE
			                            (	actionPropertyDefinitionBody (SEMI)? // ;?
			                            |	localDataPropertyDefinition SEMI
			                            |	emptyStatement
			                            )*
		                                RBRACE
{mixin="com.simpleplugin.psi.LSFListActionImpl" implements="com.simpleplugin.psi.LSFListAction"}

localDataPropertyDefinition ::= LOCAL simpleName EQUAL className LBRAC classNameList RBRAC
{mixin="com.simpleplugin.psi.declarations.impl.LSFLocalPropDeclarationImpl" implements="com.simpleplugin.psi.declarations.LSFLocalPropDeclaration"}

execActionPropertyDefinitionBody ::= (EXEC)? propertyObject LBRAC propertyExpressionList RBRAC

assignActionPropertyDefinitionBody ::= (ASSIGN)?
                                       propertyUsage LBRAC singleParameterList RBRAC
                                       ARROW
                                       propertyExpression (WHERE propertyExpression)?

ifActionPropertyDefinitionBody ::= IF propertyExpression
		                                THEN actionPropertyDefinitionBody
		                                (ELSE actionPropertyDefinitionBody)?

caseActionPropertyDefinitionBody ::= CASE (exclusiveOverrideOption)?
			                            (actionCaseBranchBody)+
			                            (ELSE actionPropertyDefinitionBody)?

actionCaseBranchBody ::= WHEN propertyExpression THEN actionPropertyDefinitionBody

multiActionPropertyDefinitionBody ::= MULTI (exclusiveOverrideOption)? nonEmptyActionPDBList

forAddObjClause ::= ADDOBJ (ID EQUAL)? customClassUsage

forActionPropertyDefinitionBody ::= FOR (propertyExpression (ORDER (DESC)? nonEmptyPropertyExpressionList)? )?
		                            inlineStatement
		                            (forAddObjClause)?
		                            DO actionPropertyDefinitionBody
		                            (ELSE actionPropertyDefinitionBody)?

whileActionPropertyDefinitionBody ::= WHILE (propertyExpression (ORDER (DESC)? nonEmptyPropertyExpressionList)? )?
		                              inlineStatement
		                              (forAddObjClause)?
		                              DO actionPropertyDefinitionBody

terminalFlowActionPropertyDefinitionBody ::= BREAK | RETURN

////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////// FORM STATEMENT /////////////////////////////
////////////////////////////////////////////////////////////////////////////////

formStatement ::=	(	formDecl
            		|	extendingFormDeclaration
		            )
                    (	formGroupObjectsList
                    |	formTreeGroupObjectList
                    |	formFiltersList
                    |	formPropertiesList
                    |	formHintsList
                    |	formEventsList
                    |	filterGroupDeclaration
                    |	formOrderByList
                    |	dialogFormDeclaration
                    |	editFormDeclaration
                    |	listFormDeclaration
                    )*
                    SEMI {pin=1}

dialogFormDeclaration ::= DIALOG customClassUsage OBJECT ID
editFormDeclaration ::= EDIT customClassUsage OBJECT ID
listFormDeclaration ::= LIST customClassUsage OBJECT ID

formDecl ::= FORM simpleNameWithCaption
		            (TITLE stringLiteral)?
		            (PRINT)?
		            (modalityTypeLiteral)?
		            (IMAGE stringLiteral)?
{mixin="com.simpleplugin.psi.declarations.impl.LSFFormDeclarationImpl" implements="com.simpleplugin.psi.declarations.LSFFormDeclaration"
    stubClass = "com.simpleplugin.psi.stubs.FormStubElement"
    elementTypeFactory = "com.simpleplugin.psi.stubs.types.LSFStubFactory.create"
    pin = 2
}

extendingFormDeclaration ::= EXTEND FORM formUsage {pin=2}

formGroupObjectsList ::= OBJECTS formGroupObjectDeclaration
		                         (COMMA formGroupObjectDeclaration)*

formTreeGroupObjectList ::= TREE (ID)? formTreeGroupObjectDeclaration
		                               (COMMA formTreeGroupObjectDeclaration)*

formGroupObjectDeclaration ::= formCommonGroupObject (formGroupObjectReportPath)? (formGroupObjectViewType)? (formGroupObjectPageSize)?
formTreeGroupObjectDeclaration ::= formCommonGroupObject (treeGroupParentDeclaration)?

treeGroupParentDeclaration ::= PARENT (propertyUsage | LBRAC nonEmptyPropertyUsageList RBRAC)

formCommonGroupObject ::= formSingleGroupObjectDeclaration | formMultiGroupObjectDeclaration

formGroupObjectReportPath ::= REPORTFILE mappedProperty

formGroupObjectViewType ::= (INIT | FIXED ) classViewType

classViewType ::= PANEL | HIDE | GRID

formGroupObjectPageSize ::= PAGESIZE intLiteral

formSingleGroupObjectDeclaration ::= formObjectDeclaration

formMultiGroupObjectDeclaration ::= (ID EQUAL)?
		                            LBRAC
			                        formObjectDeclaration (COMMA formObjectDeclaration)+
		                            RBRAC

formObjectDeclaration ::= (ID EQUAL)?
		                  className (stringLiteral)?
		                  (ON CHANGE formActionPropertyObject)?

formPropertiesList ::=  PROPERTIES LBRAC idList RBRAC formPropertyOptionsList formPropertiesNamesList
	                |	PROPERTIES formPropertyOptionsList formMappedPropertiesList

formPropertyOptionsList ::= (	propertyEditTypeLiteral
                            |	HINTNOUPDATE
                            |   HINTTABLE
                            |   TOOLBAR
                            |	COLUMNS LBRAC nonEmptyIdList RBRAC
                            |	SHOWIF formCalcPropertyObject
                            |	READONLYIF formCalcPropertyObject
                            |	BACKGROUND formCalcPropertyObject
                            |	FOREGROUND formCalcPropertyObject
                            |	HEADER formCalcPropertyObject
                            |	FOOTER formCalcPropertyObject
                            |	FORCE classViewType
                            |	TODRAW formGroupObjectEntity
                            |	BEFORE formPropertyDraw
                            |	AFTER  formPropertyDraw
                            |	ON EDIT formActionPropertyObject
                            |	ON CHANGE formActionPropertyObject
                            |	ON CHANGEWYS formActionPropertyObject
                            |	ON SHORTCUT (stringLiteral)? formActionPropertyObject
                            |	EVENTID stringLiteral
                            )*

formPropertyDraw ::= mappedProperty | ID

formMappedPropertiesList ::= (ID EQUAL)? formMappedProperty formPropertyOptionsList
		                     (COMMA (ID EQUAL)? formMappedProperty formPropertyOptionsList)*

formCalcPropertyObject ::= mappedProperty
formActionPropertyObject ::= mappedProperty

formGroupObjectEntity ::= ID
formMappedProperty ::= formPropertyName LBRAC idList RBRAC

formPropertiesNamesList ::=	(ID EQUAL)?	formPropertyName formPropertyOptionsList
		                    (COMMA (ID EQUAL)? formPropertyName formPropertyOptionsList)*

formPropertyName ::=    propertyUsage
                    |	OBJVALUE
                    |	SELECTION
                    |	ADDOBJ
                    |	ADDFORM
                    |	ADDSESSIONFORM
                    |	EDITFORM
                    |	EDITSESSIONFORM
                    |	DELETE
                    |	DELETESESSION

formFiltersList ::= FILTERS formFilterDeclaration (COMMA formFilterDeclaration)*

formHintsList ::= (HINTNOUPDATE | HINTTABLE) LIST nonEmptyPropertyUsageList

formEventsList ::= EVENTS formEventDeclaration (COMMA formEventDeclaration)*

formEventDeclaration ::= ON
                        (	OK
                        |	APPLY
                        |	CLOSE
                        |	INIT
                        |	CANCEL
                        |	DROP
                        |	QUERYOK
                        |	QUERYCLOSE
                        | 	CHANGE ID
                        )
                        formActionPropertyObject

filterGroupDeclaration ::= FILTERGROUP ID
		                   (FILTER stringLiteral stringLiteral formFilterDeclaration filterSetDefault)+

formFilterDeclaration ::= propertyExpression
filterSetDefault ::= (DEFAULT)?

formOrderByList ::= ORDER BY formPropertyDrawWithOrder
		                     (COMMA formPropertyDrawWithOrder)*

formPropertyDrawWithOrder ::= formPropertyDraw (ASC | DESC)?


////////////////////////////////////////////////////////////////////////////////
/////////////////////////////OVERRIDE STATEMENT/////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

overrideStatement ::= propertyUsage LBRAC idList RBRAC PLUSEQ
		                (WHEN propertyExpression THEN)?
		                (	propertyExpression
		                |	actionPropertyDefinition
		                )
		                (SEMI)? // ;?

////////////////////////////////////////////////////////////////////////////////
//////////////////////////////// CONSTRAINT STATEMENT //////////////////////////
////////////////////////////////////////////////////////////////////////////////

constraintStatement ::= CONSTRAINT baseEvent propertyExpression
		                (CHECKED (BY nonEmptyPropertyUsageList)? )?
		                MESSAGE stringLiteral
		                SEMI {pin = 1}

////////////////////////////////////////////////////////////////////////////////
///////////////////////////////// FOLLOWS STATEMENT ////////////////////////////
////////////////////////////////////////////////////////////////////////////////

followsStatement ::= mappedProperty FOLLOWS
                     propertyExpression (RESOLVE followsResolveType baseEvent)?
		             (COMMA propertyExpression (RESOLVE followsResolveType baseEvent)?)*
		             SEMI

followsResolveType ::= LEX_LOGICAL_LITERAL | ALL | NOTHING

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////// WRITE STATEMENT /////////////////////////////
////////////////////////////////////////////////////////////////////////////////

writeWhenStatement ::= mappedProperty ARROW propertyExpression WHEN (DO)? propertyExpression SEMI

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////// EVENT STATEMENT /////////////////////////////
////////////////////////////////////////////////////////////////////////////////

eventStatement ::= WHEN baseEvent propertyExpression inlineStatement
		                DO actionPropertyDefinitionBody (ORDER (DESC)? nonEmptyPropertyExpressionList)?
		           (SEMI)? {pin = 1} // Разобраться с точкой с запятой

////////////////////////////////////////////////////////////////////////////////
//////////////////////////// GLOBAL EVENT STATEMENT ////////////////////////////
////////////////////////////////////////////////////////////////////////////////

globalEventStatement ::= ON baseEvent (SINGLE)? (SHOWDEP ID)? actionPropertyDefinitionBody (SEMI)? {pin=1} // ;?

baseEvent ::= (APPLY | SESSION)? (FORMS nonEmptyFormUsageList)?

inlineStatement ::=   (NOINLINE (LBRAC singleParameterList RBRAC)? )? (INLINE)?

////////////////////////////////////////////////////////////////////////////////
//////////////////////////////// SHOWDEP STATEMENT //////////////////////////////
////////////////////////////////////////////////////////////////////////////////

showDepStatement ::= SHOWDEP propertyUsage FROM propertyUsage SEMI {pin=1}

////////////////////////////////////////////////////////////////////////////////
//////////////////////////////// ASPECT STATEMENT //////////////////////////////
////////////////////////////////////////////////////////////////////////////////

aspectStatement ::= (BEFORE | AFTER) mappedProperty DO actionPropertyDefinitionBody (SEMI)? {pin=1} // ;?

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////// TABLE STATEMENT /////////////////////////////
////////////////////////////////////////////////////////////////////////////////

tableStatement ::= TABLE simpleName LBRAC nonEmptyClassNameList RBRAC SEMI 
{mixin="com.simpleplugin.psi.declarations.impl.LSFTableDeclarationImpl" implements="com.simpleplugin.psi.declarations.LSFTableDeclaration"
    stubClass = "com.simpleplugin.psi.stubs.TableStubElement"
    elementTypeFactory = "com.simpleplugin.psi.stubs.types.LSFStubFactory.create"
    pin = 2
}


////////////////////////////////////////////////////////////////////////////////
/////////////////////////////// LOGGABLE STATEMENT /////////////////////////////
////////////////////////////////////////////////////////////////////////////////

loggableStatement ::= LOGGABLE nonEmptyPropertyUsageList SEMI {pin=1}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////// INDEX STATEMENT /////////////////////////////
////////////////////////////////////////////////////////////////////////////////

indexStatement ::= INDEX nonEmptyPropertyUsageList SEMI {pin=1}

////////////////////////////////////////////////////////////////////////////////
/////////////////////////////// WINDOW STATEMENT ////////////////////////////
////////////////////////////////////////////////////////////////////////////////

windowStatement ::= windowCreateStatement | windowHideStatement

windowCreateStatement ::= WINDOW windowType simpleName stringLiteral windowOptions SEMI
{mixin="com.simpleplugin.psi.declarations.impl.LSFWindowDeclarationImpl" implements="com.simpleplugin.psi.declarations.LSFWindowDeclaration"
    stubClass = "com.simpleplugin.psi.stubs.WindowStubElement"
    elementTypeFactory = "com.simpleplugin.psi.stubs.types.LSFStubFactory.create"
    pin = 3
}

windowHideStatement ::= HIDE WINDOW windowUsage SEMI {pin=2}

windowType ::= MENU | PANEL | TOOLBAR | TREE

windowOptions ::=   (	HIDETITLE
                    |	DRAWROOT
                    |	HIDESCROLLBARS
                    |	orientation
                    |	dockPosition
                    |	borderPosition
                    |	HALIGN LBRAC alignmentLiteral RBRAC
                    |	VALIGN LBRAC alignmentLiteral RBRAC
                    |	TEXTHALIGN LBRAC alignmentLiteral RBRAC
                    |	TEXTVALIGN LBRAC alignmentLiteral RBRAC
                    )*

borderPosition ::= LEFT	| RIGHT | TOP | BOTTOM
orientation ::= VERTICAL | HORIZONTAL
dockPosition ::= POSITION LBRAC intLiteral COMMA intLiteral COMMA intLiteral COMMA intLiteral RBRAC

////////////////////////////////////////////////////////////////////////////////
/////////////////////////////// NAVIGATOR STATEMENT ////////////////////////////
////////////////////////////////////////////////////////////////////////////////

navigatorStatement ::= NAVIGATOR navigatorElementStatementBody {pin=1}

navigatorElementStatementBody ::=   (   LBRACE
                                        (	addNavigatorElementStatement
                                        |	newNavigatorElementStatement
                                        |	setupNavigatorElementStatement
                                        |	emptyStatement
                                        )*
                                        RBRACE
                                    ) | emptyStatement

addNavigatorElementStatement ::= ADD navigatorElementSelector (stringLiteral)? navigatorElementInsertPositionSelector (TO windowUsage)? navigatorElementStatementBody

newNavigatorElementStatement ::= NEW simpleName (ACTION propertyUsage)? stringLiteral navigatorElementInsertPositionSelector (TO windowUsage)? (IMAGE stringLiteral)? navigatorElementStatementBody
{mixin="com.simpleplugin.psi.declarations.impl.LSFNavigatorElementDeclarationImpl" implements="com.simpleplugin.psi.declarations.LSFNavigatorElementDeclaration"
    stubClass = "com.simpleplugin.psi.stubs.NavigatorElementStubElement"
    elementTypeFactory = "com.simpleplugin.psi.stubs.types.LSFStubFactory.create"
    pin = 2
}

navigatorElementInsertPositionSelector ::=	(IN navigatorElementSelector)?
                                            (   insertRelativePositionLiteral navigatorElementSelector
                                            |	FIRST
                                            )?

setupNavigatorElementStatement ::= navigatorElementSelector (stringLiteral)? (TO windowUsage)? navigatorElementStatementBody

navigatorElementSelector ::= navigatorElementUsage

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////// DESIGN STATEMENT ////////////////////////////
////////////////////////////////////////////////////////////////////////////////

designStatement ::=	(designDeclaration | extendDesignDeclaration) componentStatementBody {pin=1}

designDeclaration ::= DESIGN formUsage (stringLiteral)? (FROM DEFAULT)? {pin=1}

extendDesignDeclaration ::= EXTEND DESIGN formUsage {pin=2}

componentStatementBody ::=  LBRACE
                            (	setObjectPropertyStatement
                            |	positionComponentsStatement
                            |	setupComponentStatement
                            |	setupGroupObjectStatement
                            |	newComponentStatement
                            |	addComponentStatement
                            |	removeComponentStatement
                            |	emptyStatement
                            )*
		                    RBRACE
	                    |	emptyStatement

setupComponentStatement ::= componentSelector componentStatementBody

setupGroupObjectStatement ::= GROUP LBRAC ID RBRAC
                              LBRACE
                              (   setObjectPropertyStatement
                              |   emptyStatement
                              )*
                              RBRACE

newComponentStatement ::= NEW multiCompoundID componentInsertPositionSelector componentStatementBody
addComponentStatement ::= ADD componentSelector componentInsertPositionSelector componentStatementBody

componentInsertPositionSelector ::= (IN componentSelector)?
                                    (   insertRelativePositionLiteral componentSelector
                                    |	FIRST
                                    )?

removeComponentStatement ::= REMOVE componentSelector (CASCADE)? SEMI

componentSelector ::=   PARENT LBRAC componentSelector RBRAC
                	|	PROPERTY LBRAC propertySelector RBRAC
                    |	multiCompoundID

propertySelector ::= mappedProperty | compoundID // compoundID?

positionComponentsStatement ::= POSITION componentSelector simplexConstraintLiteral (componentSelector)? SEMI

setObjectPropertyStatement ::= ID EQUAL componentPropertyValue SEMI

componentPropertyValue ::=  colorLiteral
                        |	stringLiteral
                        |	intLiteral
                        |	doubleLiteral
                        |	dimensionLiteral
                        |	booleanLiteral
                        |	simplexConstraintLiteral
                        |	boundsIntLiteral
                        |	boundsDoubleLiteral
                        |   containerTypeLiteral
                        |   flexAlignmentLiteral

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////// META STATEMENT //////////////////////////////
////////////////////////////////////////////////////////////////////////////////

// recoverUntil=rule_recover
metaCodeDeclarationStatement ::= META simpleName LBRAC metaDeclIdList RBRAC anyTokens END {pin=2
    mixin = "com.simpleplugin.psi.declarations.impl.LSFMetaDeclarationImpl" implements = "com.simpleplugin.psi.declarations.LSFMetaDeclaration"
    stubClass = "com.simpleplugin.psi.stubs.MetaStubElement"
    elementTypeFactory = "com.simpleplugin.psi.stubs.types.LSFStubFactory.create"
}

anyTokens ::= (<< readAny >>)*
fakeTwoDashes ::= FAKETWODASHES
fakeThreeDashes ::= FAKETHREEDASHES

private metaStatement ::= statement { recoverUntil = "meta_statement_recover" }
private meta_statement_recover ::= !(def_statement_recover_start | RBRACE) 
metaCodeBody ::= LBRACE (metaStatement*) RBRACE


//recoverUntil=rule_recover
metaCodeStatement ::= ATSIGN metacodeUsage LBRAC metaCodeIdList RBRAC metaCodeBody? SEMI {pin=2
mixin="com.simpleplugin.psi.references.impl.LSFMetaReferenceImpl" implements="com.simpleplugin.psi.references.LSFMetaReference"}

private rule_recover ::= !(AFTER | ATSIGN | BEFORE | CLASS | CONSTRAINT | DESIGN | END | EXTEND | FORM | GROUP | HIDE | ID | INDEX | LOGGABLE | META | NAVIGATOR | ON | SEMI | SHOWDEP | TABLE | WHEN | WINDOW)

metaDeclId ::=  ID
metaDeclIdList ::=  (metaDeclId (COMMA metaDeclId)*)?

metaCodeIdList ::=  (metaCodeId (COMMA metaCodeId)*)?

metaCodeId ::=  PRIMITIVE_TYPE
	        |	compoundID
	        |	metaCodeLiteral
	        |

metaCodeLiteral ::= LEX_STRING_LITERAL
                | 	LEX_UINT_LITERAL
                |	LEX_UNUMERIC_LITERAL
                |	LEX_UDOUBLE_LITERAL
                |	LEX_ULONG_LITERAL
                |	LEX_LOGICAL_LITERAL
                |	LEX_DATE_LITERAL
                |	LEX_DATETIME_LITERAL
                |	LEX_TIME_LITERAL
                |	LEX_COLOR_LITERAL
                |	NULL

////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////// COMMON /////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

emptyStatement ::= SEMI;

mappedProperty ::= propertyUsage LBRAC idList RBRAC // temporary

parameterUsage ::= simpleName | NUMBERED_PARAM | RECURSIVE_PARAM
{mixin="com.simpleplugin.psi.references.impl.LSFParamReferenceImpl" implements="com.simpleplugin.psi.references.LSFParamReference"}

simpleNameWithCaption ::= simpleName (stringLiteral)?

idList ::= (nonEmptyIdList)?
nonEmptyIdList ::= ID (COMMA ID)*

customClassUsageList ::= (nonEmptyCustomClassUsageList)?
nonEmptyCustomClassUsageList ::= customClassUsage (COMMA customClassUsage)*

moduleUsageList ::= (nonEmptyModuleUsageList)?
nonEmptyModuleUsageList ::= moduleUsage (COMMA moduleUsage)*

namespaceUsageList ::= (nonEmptyModuleUsageList)?
nonEmptyNamespaceUsageList ::= namespaceUsage (COMMA namespaceUsage)*

classNameList ::= (nonEmptyClassNameList)?
nonEmptyClassNameList ::= className (COMMA className)*


propertyUsageList ::= (nonEmptyPropertyUsageList)?
nonEmptyPropertyUsageList ::= propertyUsage (COMMA propertyUsage)*

formUsageList ::= (nonEmptyFormUsageList)?
nonEmptyFormUsageList ::= formUsage (COMMA formUsage)*

singleParameterList ::= (singleParameter (COMMA singleParameter)*)?
singleParameter ::= ID

simpleNameWithCaptionList ::= (nonEmtySimpleNameWithCaptionList)?
nonEmtySimpleNameWithCaptionList ::= simpleNameWithCaption (COMMA simpleNameWithCaption)*

actionPDBList ::= (nonEmptyActionPDBList)?
nonEmptyActionPDBList ::= actionPropertyDefinitionBody (COMMA actionPropertyDefinitionBody)*

propertyExpressionList ::= (nonEmptyPropertyExpressionList)?
nonEmptyPropertyExpressionList ::= propertyExpression (COMMA propertyExpression)*

literal ::=
        ulongLiteral
	|	uintLiteral
	|	udoubleLiteral
	|	LEX_UNUMERIC_LITERAL
	|	stringLiteral
	|	booleanLiteral
	|	dateTimeLiteral
	|	dateLiteral
	|	timeLiteral
	|	nullLiteral
	|	staticObjectID
	|	colorLiteral

builtInClassName ::= PRIMITIVE_TYPE
className ::= builtInClassName | customClassUsage

customClassUsage ::= compoundID
{mixin="com.simpleplugin.psi.references.impl.LSFClassReferenceImpl" implements="com.simpleplugin.psi.references.LSFClassReference"}

moduleUsage ::= simpleName
{mixin="com.simpleplugin.psi.references.impl.LSFModuleReferenceImpl" implements="com.simpleplugin.psi.references.LSFModuleReference"}

namespaceUsage ::= simpleName
{mixin="com.simpleplugin.psi.references.impl.LSFNamespaceReferenceImpl" implements="com.simpleplugin.psi.references.LSFNamespaceReference"}

propertyUsage ::= compoundID
{mixin="com.simpleplugin.psi.references.impl.LSFPropReferenceImpl" implements="com.simpleplugin.psi.references.LSFPropReference"}

tableUsage ::= compoundID
{mixin="com.simpleplugin.psi.references.impl.LSFTableReferenceImpl" implements="com.simpleplugin.psi.references.LSFTableReference"}

groupUsage ::= compoundID
{mixin="com.simpleplugin.psi.references.impl.LSFGroupReferenceImpl" implements="com.simpleplugin.psi.references.LSFGroupReference"}

formUsage ::= compoundID
{mixin="com.simpleplugin.psi.references.impl.LSFFormReferenceImpl" implements="com.simpleplugin.psi.references.LSFFormReference"}

windowUsage ::= compoundID
{mixin="com.simpleplugin.psi.references.impl.LSFWindowReferenceImpl" implements="com.simpleplugin.psi.references.LSFWindowReference"}

navigatorElementUsage ::= compoundID
{mixin="com.simpleplugin.psi.references.impl.LSFNavigatorElementReferenceImpl" implements="com.simpleplugin.psi.references.LSFNavigatorElementReference"}

metacodeUsage ::= compoundID

typeId ::= PRIMITIVE_TYPE | OBJECT

compoundID ::= simpleName (POINT simpleName)?

//staticObjectID ::= (ID POINT)? ID POINT ID
staticObjectID ::= ID POINT ID (POINT ID)?

//groupObjectID ::= (ID POINT)? ID POINT ID
groupObjectID ::= ID POINT ID (POINT ID)?

multiCompoundID ::= ID (POINT ID)*

exclusiveOverrideOption ::= OVERRIDE | EXCLUSIVE

colorLiteral ::= LEX_COLOR_LITERAL | (RGB LBRAC uintLiteral COMMA uintLiteral COMMA uintLiteral RBRAC)
stringLiteral ::= LEX_STRING_LITERAL
intLiteral ::= (MINUS)? uintLiteral
longLiteral ::=  (MINUS)? ulongLiteral
doubleLiteral ::= (MINUS)? LEX_UNUMERIC_LITERAL
dateLiteral ::= LEX_DATE_LITERAL
dateTimeLiteral ::= LEX_DATETIME_LITERAL
timeLiteral ::= LEX_TIME_LITERAL
booleanLiteral ::= LEX_LOGICAL_LITERAL
udoubleLiteral ::= LEX_UDOUBLE_LITERAL
uintLiteral ::= LEX_UINT_LITERAL
ulongLiteral ::= LEX_ULONG_LITERAL
nullLiteral ::= NULL

nullOption ::= NULL

dimensionLiteral ::= LBRAC intLiteral COMMA intLiteral RBRAC
boundsIntLiteral ::= LBRAC intLiteral COMMA intLiteral COMMA intLiteral COMMA intLiteral RBRAC
boundsDoubleLiteral ::= LBRAC doubleLiteral COMMA doubleLiteral COMMA doubleLiteral COMMA doubleLiteral RBRAC

simplexConstraintLiteral ::=
        TO THE LEFT
	|	TO THE RIGHT
	|	TO THE BOTTOM
	|	TO THE RIGHTBOTTOM
	|	TO NOT INTERSECT

insertRelativePositionLiteral ::= BEFORE | AFTER

containerTypeLiteral ::=    CONTAINERV
	                    |	CONTAINERH
	                    |	COLUMNS
	                    |	TABBED
	                    |	SPLITH
	                    |	SPLITV
	                    
alignmentLiteral ::= LEADING | CENTER | TRAILING

flexAlignmentLiteral ::= LEADING | CENTER | TRAILING | STRETCH


propertyEditTypeLiteral ::= EDITABLE | READONLY | SELECTOR

modalityTypeLiteral ::= DOCKED | MODAL | DOCKEDMODAL | FULLSCREEN

formSessionScopeLiteral ::= OLDSESSION | NEWSESSION | MANAGESESSION

emailRecipientTypeLiteral ::= TO | CC | BCC

emailAttachFormat ::= PDF | DOCX | HTML | RTF

