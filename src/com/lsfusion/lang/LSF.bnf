{
  psiImplUtilClass="com.lsfusion.lang.psi.LSFPsiImplUtil"

  parserClass="com.lsfusion.lang.parser.LSFParser"
  parserUtilClass="com.lsfusion.lang.parser.LSFParserUtil"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="LSF"
  psiImplClassSuffix="Impl"
  psiPackage="com.lsfusion.lang.psi"
  psiImplPackage="com.lsfusion.lang.psi.impl"
 
  elementTypeHolderClass="com.lsfusion.lang.psi.LSFTypes"
  elementTypeClass="com.lsfusion.lang.psi.LSFElementType"
  elementTypeFactory = "com.lsfusion.lang.psi.LSFElementTypeFactory.create"

  tokenTypeClass="com.lsfusion.lang.psi.LSFTokenType"

  extendedPin = false

  // additional tokens
  tokens = [
    COMMENTS='COMMENTS'
    FAKETWODASHES='##'
    FAKETHREEDASHES='###'
  ]
}

script ::= << isExpressionParsing >> propertyExpression
        | << isActionParsing >> listActionStatement*
        | moduleHeader (lazyScriptStatement*)

lazyScriptStatement ::= scriptStatement*
{
    lazy = true
    extends = "com.lsfusion.lang.psi.LSFLazyParsableElement"
}

scriptStatement ::= statement
{
    recoverWhile = "script_statement_recover"
}

simpleName ::= ID
{
    mixin="com.lsfusion.lang.psi.LSFIdImpl"
    implements="com.lsfusion.lang.psi.LSFId"
}

moduleHeader ::= MODULE moduleName SEMI
                 requireList?
                 priorityList?
                 namespaceName?
{
    pin = 2
    mixin="com.lsfusion.lang.psi.declarations.impl.LSFModuleDeclarationImpl"
    implements="com.lsfusion.lang.psi.declarations.LSFModuleDeclaration"
    stubClass = "com.lsfusion.lang.psi.stubs.ModuleStubElement"
    elementTypeFactory = "com.lsfusion.lang.psi.stubs.types.LSFStubElementTypeFactory.create"
    recoverWhile = "script_statement_recover"
}

moduleName ::= simpleName;
requireList ::= REQUIRE nonEmptyModuleUsageList SEMI {pin = 1};
priorityList ::= PRIORITY nonEmptyNamespaceUsageList SEMI {pin = 1};
namespaceName ::= NAMESPACE namespaceUsage SEMI
{
    pin = 2;
    mixin="com.lsfusion.lang.psi.declarations.impl.LSFExplicitNamespaceDeclarationImpl"
    implements="com.lsfusion.lang.psi.declarations.LSFExplicitNamespaceDeclaration"
    stubClass = "com.lsfusion.lang.psi.stubs.ExplicitNamespaceStubElement"
    elementTypeFactory = "com.lsfusion.lang.psi.stubs.types.LSFStubElementTypeFactory.create"
}

private statement ::=   constraintStatement
                    |	groupStatement
                    |	overrideStatement // starts with ID
                    |	classStatement
                    |	followsStatement // starts with ID
                    |	writeWhenStatement // starts with ID
                    |	explicitInterfacePropertyStatement
                    |	eventStatement
                    |	showDepStatement
                    |	globalEventStatement
                    |	aspectStatement
                    |	tableStatement
                    |	loggableStatement
                    |	indexStatement
                    |	formStatement
                    |	designStatement
                    |	windowStatement
                    |	navigatorStatement
                    |	metaCodeStatement // ?
                    |	metaCodeDeclarationStatement // ?
                    |   externalStatement
                    |	emptyStatement
                    |   stubStatement
                    
externalStatement ::= EXTERNAL (externalProperty | externalClass | externalModule | externalPropertyDraw | externalFormObject) SEMI {pin = 1}
externalProperty ::= PROPERTY nonEmptyNoContextPropertyUsageList {pin = 1} 
externalClass ::= CLASS nonEmptyClassNameList {pin = 1}
externalModule ::= MODULE nonEmptyModuleUsageList {pin = 1}
externalPropertyDraw ::= PROPERTYDRAW formUsage formPropertyDrawUsage
{
    pin = 1
    implements="com.lsfusion.lang.psi.context.FormContext"
    methods = [resolveFormDecl]
}

externalFormObject ::= OBJECT formUsage objectUsage
{
    pin = 1
    implements="com.lsfusion.lang.psi.context.FormContext"
    methods = [resolveFormDecl]
}

// some statements are pinned after the first token, so we need these fake rules to pin incomplete statements
stubStatement ::=
    EXTEND (CLASS | FORM | DESIGN) ID
    | CLASS (ABSTRACT | NATIVE)? COMPLEX? ID
    | (ATSIGN | FORM | GROUP | META | DESIGN | TABLE) ID
    | WINDOW windowType ID
    {pin(".*") = 1}

private script_statement_recover ::= !statement_start
// Important ! after recover the rule should mandatory be pinned (matched)
private statement_start ::= ID | AFTER | BEFORE | HIDE | INDEX | LOGGABLE | NAVIGATOR | ON | SHOWDEP | WHEN | CONSTRAINT | EXTERNAL
                            | CLASS | ATSIGN | FORM | GROUP | META | DESIGN | TABLE | WINDOW | EXTEND | SEMI


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////// CLASS STATEMENT /////////////////////////////
////////////////////////////////////////////////////////////////////////////////

classDecl ::= CLASS (ABSTRACT | NATIVE)? COMPLEX? simpleNameWithCaption
{
     mixin = "com.lsfusion.lang.psi.declarations.impl.LSFClassDeclarationImpl"
     implements = "com.lsfusion.lang.psi.declarations.LSFClassDeclaration"
     stubClass = "com.lsfusion.lang.psi.stubs.ClassStubElement"
     elementTypeFactory = "com.lsfusion.lang.psi.stubs.types.LSFStubElementTypeFactory.create"
}

extendingClassDeclaration ::= EXTEND CLASS customClassUsageWrapper

customClassUsageWrapper ::= customClassUsage // for usages search filter

classStatement ::= (classDecl | extendingClassDeclaration) classInstancesAndParents {
    pin = 1
    mixin="com.lsfusion.lang.psi.extend.impl.LSFClassExtendImpl"
    implements="com.lsfusion.lang.psi.extend.LSFClassExtend"
    stubClass = "com.lsfusion.lang.psi.stubs.extend.ExtendClassStubElement"
    elementTypeFactory = "com.lsfusion.lang.psi.stubs.types.LSFStubElementTypeFactory.create"
}

private classInstancesAndParents ::=    LBRACE staticObjectDeclList RBRACE (classParentsList SEMI)? | (classParentsList)? SEMI {pin(".*") = 1}

classParentsList ::= COLON nonEmptyCustomClassUsageList {pin = 1}

staticObjectDeclList ::= (nonEmptyStaticObjectDeclList)?

nonEmptyStaticObjectDeclList ::= staticObjectDecl (COMMA staticObjectDecl)*

staticObjectDecl ::= simpleNameWithCaption
{mixin="com.lsfusion.lang.psi.declarations.impl.LSFStaticObjectDeclarationImpl" implements="com.lsfusion.lang.psi.declarations.LSFStaticObjectDeclaration"}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////// GROUP STATEMENT /////////////////////////////
////////////////////////////////////////////////////////////////////////////////

groupStatement ::= GROUP simpleNameWithCaption (COLON groupUsage)? SEMI
{
    pin = 2
    implements="com.lsfusion.lang.psi.declarations.LSFGroupDeclaration"
    mixin="com.lsfusion.lang.psi.declarations.impl.LSFGroupDeclarationImpl"
    stubClass = "com.lsfusion.lang.psi.stubs.GroupStubElement"
    elementTypeFactory = "com.lsfusion.lang.psi.stubs.types.LSFStubElementTypeFactory.create"
}


////////////////////////////////////////////////////////////////////////////////
//////////////////////////////// PROPERTY STATEMENT ////////////////////////////
////////////////////////////////////////////////////////////////////////////////

explicitInterfacePropertyStatement ::= explicitValuePropertyStatement
{
    mixin="com.lsfusion.lang.psi.declarations.impl.LSFExplicitInterfacePropStatementImpl"
    implements="com.lsfusion.lang.psi.declarations.LSFExplicitInterfacePropStatement"
    stubClass="com.lsfusion.lang.psi.stubs.interfaces.ExplicitInterfaceStubElement"
    elementTypeFactory="com.lsfusion.lang.psi.stubs.types.LSFStubElementTypeFactory.create"
}

explicitValuePropertyStatement ::= implicitValuePropertyStatement
{
    mixin="com.lsfusion.lang.psi.declarations.impl.LSFExplicitValuePropStatementImpl"
    implements="com.lsfusion.lang.psi.declarations.LSFExplicitValuePropStatement"
    stubClass="com.lsfusion.lang.psi.stubs.interfaces.ExplicitValueStubElement"
    elementTypeFactory="com.lsfusion.lang.psi.stubs.types.LSFStubElementTypeFactory.create"
}

implicitValuePropertyStatement ::= implicitInterfacePropertyStatement
{
    mixin="com.lsfusion.lang.psi.declarations.impl.LSFImplicitValuePropStatementImpl"
    implements="com.lsfusion.lang.psi.declarations.LSFImplicitValuePropStatement"
    stubClass="com.lsfusion.lang.psi.stubs.interfaces.ImplicitValueStubElement"
    elementTypeFactory="com.lsfusion.lang.psi.stubs.types.LSFStubElementTypeFactory.create"
}

implicitInterfacePropertyStatement ::= propertyStatement
{
    mixin="com.lsfusion.lang.psi.declarations.impl.LSFImplicitInterfacePropStatementImpl"
    implements="com.lsfusion.lang.psi.declarations.LSFImplicitInterfacePropStatement"
    stubClass="com.lsfusion.lang.psi.stubs.interfaces.ImplicitInterfaceStubElement"
    elementTypeFactory="com.lsfusion.lang.psi.stubs.types.LSFStubElementTypeFactory.create"
}

propertyStatement ::= propertyDeclaration equalsSign
                      propertyImplementation
                      propertyOptions
                      << semicolonIfNeeded >>
{
    pin = 1
    mixin="com.lsfusion.lang.psi.declarations.impl.LSFGlobalPropDeclarationImpl"
    implements="com.lsfusion.lang.psi.declarations.LSFGlobalPropDeclaration,com.lsfusion.lang.psi.context.ModifyParamContext,com.lsfusion.lang.psi.LSFInterfacePropStatement"
    stubClass = "com.lsfusion.lang.psi.stubs.PropStubElement"
    elementTypeFactory = "com.lsfusion.lang.psi.stubs.types.LSFStubElementTypeFactory.create"
    methods = [ getContextModifier getContextInferrer ]
}

private propertyImplementation ::= actionStatement | propertyCalcStatement

propertyCalcStatement ::= (expressionUnfriendlyPD | propertyExpression)

actionStatement ::= ACTION (actionUnfriendlyPD | topActionPropertyDefinitionBody) {
    pin = 1
    // actually declare context, but it's pretty difficult to implement using only classes
    implements="com.lsfusion.lang.psi.context.ExtendParamContext"
    methods = [ getContextModifier getContextInferrer ]
}

actionUnfriendlyPD ::= abstractActionPropertyDefinition
                        |	addFormActionPropertyDefinitionBody
                        |	editFormActionPropertyDefinitionBody
                        |	customActionPropertyDefinitionBody
    	                |   nativeActionPropertyDefinition
{methods = [ resolveValueParamClasses]}

propertyDeclParams ::= LBRAC classParamDeclareList RBRAC

propertyDeclaration ::= simpleNameWithCaption propertyDeclParams?
{methods = [ resolveParamDecls ]}

paramDeclare ::= simpleName
{
    mixin="com.lsfusion.lang.psi.declarations.impl.LSFParamDeclarationImpl"
    implements="com.lsfusion.lang.psi.declarations.LSFParamDeclaration"
}

classParamDeclare ::= (className paramDeclare) | paramDeclare
{
    implements="com.lsfusion.lang.psi.context.ClassParamDeclareContext"
    methods = [ resolveClass ensureClass ]
}

classParamDeclareList ::= (nonEmptyClassParamDeclareList)?
nonEmptyClassParamDeclareList ::= classParamDeclare (COMMA classParamDeclare)*

propertyExpression ::= ifPE
{
    implements = "com.lsfusion.lang.psi.context.LSFExpression"
    methods = [ resolveValueClass resolveParams resolveInferredValueClass inferParamClasses getValueClassNames getValuePropertyNames]
}

ifPE ::= orPE (IF orPE)*
{implements = "com.lsfusion.lang.psi.context.LSFExpression" methods = [ resolveInferredValueClass inferParamClasses getValueClassNames getValuePropertyNames]}

orPE ::= xorPE (OR xorPE)*
{implements = "com.lsfusion.lang.psi.context.LSFExpression" methods = [ resolveInferredValueClass inferParamClasses getValueClassNames getValuePropertyNames]}

xorPE ::= andPE (XOR andPE)*
{implements = "com.lsfusion.lang.psi.context.LSFExpression" methods = [ resolveInferredValueClass inferParamClasses getValueClassNames getValuePropertyNames]}

andPE ::= notPE (AND notPE)*
{implements = "com.lsfusion.lang.psi.context.LSFExpression" methods = [ resolveInferredValueClass inferParamClasses getValueClassNames getValuePropertyNames]}

notPE ::= (NOT notPE) | equalityPE
{implements = "com.lsfusion.lang.psi.context.LSFExpression" methods = [ resolveInferredValueClass inferParamClasses getValueClassNames getValuePropertyNames]}

equalityPE ::= relationalPE (EQ_OPERAND relationalPE)?
{implements = "com.lsfusion.lang.psi.context.LSFExpression" methods = [ resolveInferredValueClass inferParamClasses getValueClassNames getValuePropertyNames]}

relationalPE ::= additiveORPE (((LESS | GREATER | LESS_EQUALS | GREATER_EQUALS) additiveORPE) | typePropertyDefinition)?
{implements = "com.lsfusion.lang.psi.context.LSFExpression" methods = [ resolveInferredValueClass inferParamClasses getValueClassNames getValuePropertyNames]}

additiveORPE ::= additivePE (ADDOR_OPERAND additivePE)*
{implements = "com.lsfusion.lang.psi.context.LSFExpression" methods = [ resolveInferredValueClass inferParamClasses getValueClassNames getValuePropertyNames]}

additivePE ::= multiplicativePE ((PLUS | MINUS) multiplicativePE)*
{implements = "com.lsfusion.lang.psi.context.LSFExpression" methods = [ resolveInferredValueClass inferParamClasses getValueClassNames getValuePropertyNames]}

typeMult ::= MULT | DIV
multiplicativePE ::= unaryMinusPE (typeMult unaryMinusPE)*
{implements = "com.lsfusion.lang.psi.context.LSFExpression" methods = [ resolveInferredValueClass inferParamClasses getValueClassNames getValuePropertyNames]}

unaryMinusPE ::= (MINUS unaryMinusPE) | postfixUnaryPE
{implements = "com.lsfusion.lang.psi.context.LSFExpression" methods = [ resolveInferredValueClass inferParamClasses getValueClassNames getValuePropertyNames]}

postfixUnaryPE ::= simplePE (LSQBR uintLiteral RSQBR)?
{implements = "com.lsfusion.lang.psi.context.LSFExpression" methods = [ resolveInferredValueClass inferParamClasses getValueClassNames getValuePropertyNames]}

simplePE ::= (LBRAC propertyExpression RBRAC) | expressionPrimitive
{implements = "com.lsfusion.lang.psi.context.LSFExpression" methods = [ resolveInferredValueClass inferParamClasses getValueClassNames getValuePropertyNames]}

expressionPrimitive ::= <<fullCompoundParamDeclareCheck>> expressionFriendlyPD | exprParameterUsage
{implements = "com.lsfusion.lang.psi.context.LSFExpression" methods = [ resolveInferredValueClass inferParamClasses getValueClassNames getValuePropertyNames]}

expressionFriendlyPD ::= joinPropertyDefinition
	    |	multiPropertyDefinition
	    |	overridePropertyDefinition
	    |	ifElsePropertyDefinition
	    |	maxPropertyDefinition
	    |	casePropertyDefinition
	    |	partitionPropertyDefinition
	    |	recursivePropertyDefinition
	    |	structCreationPropertyDefinition
	    |	concatPropertyDefinition
	    |	castPropertyDefinition
	    |	sessionPropertyDefinition
	    |	signaturePropertyDefinition
	    |   activeTabPropertyDefinition
	    |	literal
{
    implements = "com.lsfusion.lang.psi.context.LSFExpression"
    methods = [ resolveInferredValueClass inferParamClasses getValueClassNames getValuePropertyNames ]
}

expressionUnfriendlyPD ::= dataPropertyDefinition
                           |   nativePropertyDefinition
                           |   abstractPropertyDefinition
                           |   formulaPropertyDefinition
                           |   groupPropertyDefinition
                           |   filterPropertyDefinition
{methods = [ resolveUnfriendValueClass resolveValueParamClasses]}

joinPropertyDefinition ::= JOIN? propertyObject LBRAC propertyExpressionList RBRAC
{
    implements = "com.lsfusion.lang.psi.context.LSFExpression, com.lsfusion.lang.psi.context.PropertyUsageContext"
    methods = [ resolveInferredValueClass resolveParamClasses inferParamClasses getParamList getValueClassNames getValuePropertyNames ]
}

overridePropertyDefinition ::= (OVERRIDE | EXCLUSIVE) nonEmptyPropertyExpressionList
{implements = "com.lsfusion.lang.psi.context.LSFExpression" methods = [ resolveInferredValueClass inferParamClasses getValueClassNames getValuePropertyNames ]}

ifElsePropertyDefinition ::= IF propertyExpression
                                    THEN propertyExpression
                                    (ELSE propertyExpression)?   // check greedy
{
    pin = 1
    implements = "com.lsfusion.lang.psi.context.LSFExpression"
    methods = [ resolveInferredValueClass inferParamClasses getValueClassNames getValuePropertyNames ]
}

maxPropertyDefinition ::= (MAX | MIN) nonEmptyPropertyExpressionList
{
    pin = 1
    implements = "com.lsfusion.lang.psi.context.LSFExpression"
    methods = [ resolveInferredValueClass inferParamClasses getValueClassNames getValuePropertyNames ]
}

caseBranchBody ::= WHEN propertyExpression (THEN propertyExpression) {pin(".*") = 1}
casePropertyDefinition ::= CASE (exclusiveOverrideOption)?
                           (caseBranchBody)+
                           (ELSE propertyExpression)?
{
    pin = 1
    implements = "com.lsfusion.lang.psi.context.LSFExpression"
    methods = [ resolveInferredValueClass inferParamClasses getValueClassNames getValuePropertyNames ]
}

multiPropertyDefinition ::= MULTI nonEmptyPropertyExpressionList (exclusiveOverrideOption)?
{
    pin = 1
    implements = "com.lsfusion.lang.psi.context.LSFExpression"
    methods = [ resolveInferredValueClass inferParamClasses getValueClassNames getValuePropertyNames ]
}

partitionPropertyBy ::= BY nonEmptyPropertyExpressionList
partitionPropertyDefinition ::= PARTITION
                                (   (SUM | PREV)
                                |   UNGROUP propertyUsage
                                    (   PROPORTION (STRICT)? ROUND LBRAC LEX_UINT_LITERAL RBRAC
                                    |   LIMIT (STRICT)?
                                    )
                                )
                                propertyExpression (partitionPropertyBy)?
                                (ORDER (DESC )? nonEmptyPropertyExpressionList)?
                                (WINDOW EXCEPTLAST)?
{
    pin = 1
    implements = "com.lsfusion.lang.psi.context.LSFExpression, com.lsfusion.lang.psi.context.PropertyUsageContext"
    methods = [ resolveInferredValueClass resolveParamClasses inferParamClasses getParamList getValueClassNames getValuePropertyNames ]
}

recursivePropertyDefinition ::= RECURSION propertyExpression STEP propertyExpression (CYCLES (YES |	NO | IMPOSSIBLE))?
{
    pin = 1
    implements = "com.lsfusion.lang.psi.context.LSFExpression"
    methods = [ resolveInferredValueClass inferParamClasses getValueClassNames getValuePropertyNames ]
}

structCreationPropertyDefinition ::= STRUCT LBRAC nonEmptyPropertyExpressionList RBRAC
{
    pin = 1
    implements = "com.lsfusion.lang.psi.context.LSFExpression"
    methods = [ resolveInferredValueClass inferParamClasses getValueClassNames getValuePropertyNames ]
}

castPropertyDefinition ::= builtInClassName LBRAC propertyExpression RBRAC
{implements = "com.lsfusion.lang.psi.context.LSFExpression" methods = [ resolveInferredValueClass inferParamClasses getValueClassNames getValuePropertyNames ]}

concatPropertyDefinition ::= CONCAT stringLiteral COMMA nonEmptyPropertyExpressionList
{implements = "com.lsfusion.lang.psi.context.LSFExpression" methods = [ resolveInferredValueClass inferParamClasses getValueClassNames getValuePropertyNames ]}

sessionPropertyType ::= PREV | CHANGED | SET | DROPPED | SETCHANGED | DROPCHANGED | DROPSET 
sessionPropertyDefinition ::= sessionPropertyType LBRAC propertyExpression RBRAC
{implements = "com.lsfusion.lang.psi.context.LSFExpression" methods = [ resolveInferredValueClass inferParamClasses getValueClassNames getValuePropertyNames ]}

signaturePropertyDefinition ::= (CLASS) LBRAC propertyExpression RBRAC
{implements = "com.lsfusion.lang.psi.context.LSFExpression" methods = [ resolveInferredValueClass inferParamClasses getValueClassNames getValuePropertyNames ]}

activeTabPropertyDefinition ::= ACTIVE TAB componentUsage FORM formUsage
{
    implements = "com.lsfusion.lang.psi.context.LSFExpression, com.lsfusion.lang.psi.context.FormContext" 
    methods = [ resolveInferredValueClass inferParamClasses getValueClassNames getValuePropertyNames resolveFormDecl]
}

propertyExprObject ::= LSQBR EQUALS propertyImplementation RSQBR
{implements="com.lsfusion.lang.psi.context.ModifyParamContext" methods = [ getContextModifier getContextInferrer ] }

propertyObject ::=  propertyUsage | propertyExprObject
noContextPropertyUsage ::= propertyUsage
{implements = "com.lsfusion.lang.psi.context.PropertyUsageContext" methods = [ resolveParamClasses getParamList ]}


dataPropertyDefinition ::= DATA (dataPropertySessionModifier)? className (LBRAC classNameList RBRAC)
{
    pin(".*") = 1;
    implements = "com.lsfusion.lang.psi.context.UnfriendlyPE"
    methods = [ resolveUnfriendValueClass resolveValueParamClasses getValueParamClassNames getValueClassNames getValuePropertyNames getMigrationClassNames ]
}
dataPropertySessionModifier ::= LOCAL nestedLocalModifier

nativePropertyDefinition ::= NATIVE className LBRAC classNameList RBRAC
{
    pin = 1
    implements = "com.lsfusion.lang.psi.context.UnfriendlyPE"
    methods = [ resolveUnfriendValueClass resolveValueParamClasses getValueParamClassNames getValueClassNames getValuePropertyNames ]
}

abstractPropertyDefinition ::= ABSTRACT ((CASE | MULTI | VALUE) abstractExclusiveOverrideOption?)? 
                               (CHECKED)? className LBRAC classNameList RBRAC
{
    implements = "com.lsfusion.lang.psi.context.UnfriendlyPE"
    methods = [ resolveUnfriendValueClass resolveValueParamClasses getValueParamClassNames getValueClassNames getValuePropertyNames ]
}

formulaPropertyDefinition ::= FORMULA (NULL)? (builtInClassName)? formulaPropertySyntaxList
{
    pin = 1
    implements = "com.lsfusion.lang.psi.context.UnfriendlyPE"
    methods = [ resolveUnfriendValueClass resolveValueParamClasses getValueParamClassNames getValueClassNames getValuePropertyNames ]
}

formulaPropertySyntaxList ::= formulaPropertySyntax (COMMA formulaPropertySyntax)*

formulaPropertySyntax ::= formulaPropertySyntaxType stringLiteral 

formulaPropertySyntaxType ::= (PG | MS)?

groupingType ::= SUM | MAX | MIN | CONCAT | AGGR | EQUAL | LAST | NAGGR
groupPropertyBy ::= BY nonEmptyPropertyExpressionList;
orderPropertyBy ::= ORDER (DESC)? nonEmptyPropertyExpressionList 
groupPropertyDefinition ::= GROUP groupingType
		                    nonEmptyPropertyExpressionList
		                    (groupPropertyBy)?
		                    (orderPropertyBy)?
		                    (WHERE propertyExpression)?
{
    implements="com.lsfusion.lang.psi.context.ModifyParamContext, com.lsfusion.lang.psi.context.UnfriendlyPE"
    methods = [ getContextModifier getContextInferrer resolveUnfriendValueClass resolveValueParamClasses getValueParamClassNames getValueClassNames getValuePropertyNames ] 
}		                    

filterPropertyDefinition ::= (FILTER | ORDER | VIEW) groupObjectID
{
    implements = "com.lsfusion.lang.psi.context.UnfriendlyPE"
    methods = [ resolveUnfriendValueClass resolveValueParamClasses getValueParamClassNames getValueClassNames getValuePropertyNames ]
}

typeIs ::= IS | AS
typePropertyDefinition ::= typeIs className {pin = 1}


propertyOptions ::= (   IN groupUsage
                    |	persistentSetting
                    |   COMPLEX
                    |   NOHINT
                    |	TABLE tableUsage
                    |	shortcutSetting
                    |	asEditActionSetting
                    |	toolbarSetting
                    |	fixedCharWidthSetting
                    |	minCharWidthSetting
                    |	maxCharWidthSetting
                    |	prefCharWidthSetting
                    |	imageSetting
                    |	editKeySetting
                    |	autosetSetting
                    |	confirmSetting
                    |	regexpSetting
                    |	loggableSetting
                    |	echoSymbolsSetting
                    |	indexSetting
                    |	aggPropSetting
                    |	notNullSetting
                    |	onEditEventSetting
                    |	eventIdSetting
                    |   ATSIGN2 simpleName
                    )*

shortcutSetting ::= SHORTCUT noContextPropertyUsage {pin = 1}
toolbarSetting ::= TOOLBAR
persistentSetting ::= PERSISTENT
fixedCharWidthSetting ::= FIXEDCHARWIDTH intLiteral
minCharWidthSetting ::= MINCHARWIDTH intLiteral
maxCharWidthSetting ::= MAXCHARWIDTH intLiteral
prefCharWidthSetting ::= PREFCHARWIDTH intLiteral
imageSetting ::= IMAGE stringLiteral
editKeySetting ::= EDITKEY stringLiteral (SHOW | hideEditKey)?
autosetSetting ::= AUTOSET
confirmSetting ::= CONFIRM
regexpSetting ::= REGEXP stringLiteral (stringLiteral)?
loggableSetting ::= LOGGABLE
echoSymbolsSetting ::= ECHO
indexSetting ::= INDEXED
aggPropSetting ::= AGGPROP
notNullSetting ::= NOT nullOption (DELETE)? baseEvent
onEditEventSetting ::= ON formEventType actionPropertyDefinitionBody
asEditActionSetting ::= ASON formEventType noContextPropertyUsage {pin = 1}
eventIdSetting ::= EVENTID stringLiteral

hideEditKey ::= HIDE

formEventType ::= (CHANGE | GROUPCHANGE | CHANGEWYS | EDIT)

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////// ACTION PROPERTIES ///////////////////////////
////////////////////////////////////////////////////////////////////////////////

abstractActionPropertyDefinition ::= ABSTRACT
                                    (   ((CASE | MULTI) abstractExclusiveOverrideOption?)
                                    |	(LIST abstractCaseAddOption?)
                                    )?
                                    (CHECKED)?
                                    LBRAC classNameList RBRAC
{
    implements = "com.lsfusion.lang.psi.context.UnfriendlyPE"
    methods = [ resolveUnfriendValueClass resolveValueParamClasses getValueParamClassNames getValueClassNames getValuePropertyNames ]
}


nativeActionPropertyDefinition ::= NATIVE LBRAC classNameList RBRAC
{
    implements = "com.lsfusion.lang.psi.context.UnfriendlyPE"
    methods = [ resolveUnfriendValueClass resolveValueParamClasses getValueParamClassNames getValueClassNames getValuePropertyNames ]
}

private topActionPropertyDefinitionBody ::= actionPropertyDefinitionBody

// extendContextActionPDB comes before keepContextActionPDB to check assign action before exec action
actionPropertyDefinitionBody ::=    customActionPDB
                                |   extendContextActionPDB
                                |	keepContextActionPDB
{
    implements = "com.lsfusion.lang.psi.context.ActionExpression"
    methods = [ inferActionParamClasses ]
}

private extendContextActionPDB ::=  assignActionPropertyDefinitionBody
                        |	forActionPropertyDefinitionBody
                        |   whileActionPropertyDefinitionBody
                        |	changeClassActionPropertyDefinitionBody
                        |	deleteActionPropertyDefinitionBody
                        |	addObjectActionPropertyDefinitionBody

private keepContextActionPDB ::=    listActionPropertyDefinitionBody
                        |	requestInputActionPropertyDefinitionBody
                        |	activeFormActionPropertyDefinitionBody
                        |	activateActionPropertyDefinitionBody
                        |	execActionPropertyDefinitionBody
                        |   tryActionPropertyDefinitionBody
                        |	ifActionPropertyDefinitionBody
                        |	caseActionPropertyDefinitionBody
                        |	multiActionPropertyDefinitionBody
                        |	terminalFlowActionPropertyDefinitionBody
                        |   applyActionPropertyDefinitionBody
                        |   cancelActionPropertyDefinitionBody

private customActionPDB ::= formActionPropertyDefinitionBody
                |   messageActionPropertyDefinitionBody
                |   asyncUpdateActionPropertyDefinitionBody
                |   seekObjectActionPropertyDefinitionBody
                |   confirmActionPropertyDefinitionBody
                |   emailActionPropertyDefinitionBody
                |	fileActionPropertyDefinitionBody
                |	evalActionPropertyDefinitionBody
                |	drillDownActionPropertyDefinitionBody
                |	focusActionPropertyDefinitionBody
                |   readActionPropertyDefinitionBody
                |   writeActionPropertyDefinitionBody
                |   importActionPropertyDefinitionBody
                |   newThreadActionPropertyDefinitionBody
                |   newExecutorActionPropertyDefinitionBody
                |   newSessionActionPropertyDefinitionBody

private mappedForm ::= ((   (DIALOG | EDIT) customClassUsage
                    OBJECT propertyExpression)
                |   
                (formUsage
               		(formActionObjectList)?) ) {pin =1}

formActionObjectUsage ::= objectUsage EQUALS propertyExpression {pin = 1}
formActionPropertyDefinitionBody ::=
	    FORM mappedForm
		(   contextFilterDefinition
		|   initFilterDefinition
		|   MANAGESESSION
		|   modalityTypeLiteral
		|   CHECK
		|   SHOWDROP 
		|   NOCANCEL
		|   formPrintTypeLiteral
		|   formExportLiteral  
		|   READONLY
		)*
{
    pin = 1
    implements="com.lsfusion.lang.psi.context.ActionExpression, com.lsfusion.lang.psi.context.FormContext"
    methods = [inferActionParamClasses resolveFormDecl]
}

contextFilterDefinition ::= CONTEXTFILTER formActionObjectUsage {pin = 1}

initFilterDefinition ::= INITFILTER formPropertyDrawUsage {pin = 1}

formActionObjectList ::= OBJECTS formActionObjectUsage (COMMA formActionObjectUsage)* {pin(".*") = 1}

customActionPropertyDefinitionBody ::= CUSTOM ((javaClassStringUsage (LBRAC classNameList RBRAC)?)  | codeLiteral) (NULL)?
{
    pin = 1
    implements="com.lsfusion.lang.psi.context.UnfriendlyPE"
    methods = [resolveUnfriendValueClass resolveValueParamClasses getValueParamClassNames getValueClassNames getValuePropertyNames]
}

javaClassStringUsage ::= stringLiteral
{
    mixin="com.lsfusion.lang.psi.references.impl.LSFJavaClassStringReferenceImpl"
    implements="com.lsfusion.lang.psi.references.LSFJavaClassStringReference"
}

addFormActionPropertyDefinitionBody ::= ADDFORM (SESSION | NESTED)? customClassUsage
{
    pin = 1
    implements="com.lsfusion.lang.psi.context.UnfriendlyPE"
    methods = [resolveUnfriendValueClass resolveValueParamClasses getValueParamClassNames getValueClassNames getValuePropertyNames]
}

editFormActionPropertyDefinitionBody ::= EDITFORM (SESSION | NESTED)? customClassUsage
{
    pin = 1
    implements="com.lsfusion.lang.psi.context.UnfriendlyPE"
    methods = [resolveUnfriendValueClass resolveValueParamClasses getValueParamClassNames getValueClassNames getValuePropertyNames]
}

addObjectActionPropertyDefinitionBody ::= ADDOBJ customClassUsage (WHERE propertyExpression)? (TO mappedPropertyExprParam)?
{
    pin = 1
    implements="com.lsfusion.lang.psi.context.ExtendParamContext, com.lsfusion.lang.psi.context.ActionExpression"
    methods = [ getContextModifier getContextInferrer inferActionParamClasses ]
}

emailActionPropertyDefinitionBody ::=
		EMAIL
		(FROM propertyExpression)?
		SUBJECT propertyExpression
		(emailRecipientTypeLiteral propertyExpression)*
		(	INLINE formEmailToObjects
		|	ATTACH emailAttachFormat (NAME propertyExpression)? formEmailToObjects
		|   ATTACH FILE propertyExpression (NAME propertyExpression)?
		)*
{
    pin = 1
    implements="com.lsfusion.lang.psi.context.ActionExpression"
    methods = [inferActionParamClasses]
}

formEmailToObjects ::= formUsage formActionObjectList?
{
    pin = 1
    implements="com.lsfusion.lang.psi.context.FormContext"
    methods = [resolveFormDecl]
}

confirmActionPropertyDefinitionBody ::= CONFIRM propertyExpression
{
    pin = 1
    implements="com.lsfusion.lang.psi.context.ActionExpression"
    methods = [inferActionParamClasses]
}

messageActionPropertyDefinitionBody ::= MESSAGE (NOWAIT)? propertyExpression
{
    pin = 1
    implements="com.lsfusion.lang.psi.context.ActionExpression"
    methods = [inferActionParamClasses]
}

asyncUpdateActionPropertyDefinitionBody ::= ASYNCUPDATE propertyExpression
{
    pin = 1
    implements="com.lsfusion.lang.psi.context.ActionExpression"
    methods = [inferActionParamClasses]
}

seekObjectActionPropertyDefinitionBody ::= SEEK (FIRST | LAST)? 
                                            (   (objectID EQUALS propertyExpression) 
                                            |   (groupObjectID (OBJECTS formActionObjectUsage (COMMA formActionObjectUsage)*)?) 
                                            )
{                        
    pin = 1
    implements="com.lsfusion.lang.psi.context.ActionExpression, com.lsfusion.lang.psi.context.FormContext"
    methods = [inferActionParamClasses resolveFormDecl] 
}

fileActionPropertyDefinitionBody ::= LOADFILE propertyExpression 
                                   | OPENFILE propertyExpression 
                                   | SAVEFILE propertyExpression (NAME propertyExpression)?
{
    pin = 1
    implements="com.lsfusion.lang.psi.context.ActionExpression"
    methods = [inferActionParamClasses]
}

changeClassActionPropertyDefinitionBody ::= CHANGECLASS exprParameterUsage TO customClassUsage (WHERE propertyExpression)?
{
    pin = 1
    implements="com.lsfusion.lang.psi.context.ExtendParamContext, com.lsfusion.lang.psi.context.ActionExpression"
    methods = [ getContextModifier getContextInferrer inferActionParamClasses ]
}

deleteActionPropertyDefinitionBody ::= DELETE exprParameterUsage (WHERE propertyExpression)?
{
    pin = 1
    implements="com.lsfusion.lang.psi.context.ExtendParamContext, com.lsfusion.lang.psi.context.ActionExpression"
    methods = [ getContextModifier getContextInferrer inferActionParamClasses ]
}

evalActionPropertyDefinitionBody ::= EVAL propertyExpression
{
    pin = 1
    implements="com.lsfusion.lang.psi.context.ActionExpression"
    methods = [inferActionParamClasses]
}

focusActionPropertyDefinitionBody ::= FOCUS formPropertyDrawID
{
    pin = 1
    implements="com.lsfusion.lang.psi.context.ActionExpression"
    methods = [inferActionParamClasses]
}

readActionPropertyDefinitionBody ::= READ propertyExpression TO propertyUsage ((MOVE propertyExpression) | (DELETE))?
{
    pin = 1
    implements="com.lsfusion.lang.psi.context.ActionExpression"
    methods = [inferActionParamClasses]
}

writeActionPropertyDefinitionBody ::= WRITE propertyExpression FROM propertyExpression
{
    pin = 1
    implements="com.lsfusion.lang.psi.context.ActionExpression"
    methods = [inferActionParamClasses]
}

importActionPropertyDefinitionBody ::= IMPORT importActionSourceType TO nonEmptyPropertyUsageListWithIds FROM propertyExpression (WHERE propertyExpression)?
{
    pin = 1
    implements="com.lsfusion.lang.psi.context.ActionExpression"
    methods = [inferActionParamClasses]
}

importActionSourceType ::=  XLS (SHEET propertyExpression)?
                        |   XLSX (SHEET propertyExpression)?
                        |   DBF
                        |   (CSV (stringLiteral)? (NOHEADER)? (CHARSET stringLiteral)?)
                        |   XML (ATTR)?
                        |   JDBC
                        |   MDB

newThreadActionPropertyDefinitionBody ::= NEWTHREAD actionPropertyDefinitionBody
                                        (   CONNECTION propertyExpression
                                        |   (SCHEDULE (PERIOD propertyExpression)? (DELAY propertyExpression)?)
                                        )?
{
    pin = 1
    implements="com.lsfusion.lang.psi.context.ActionExpression"
    methods = [inferActionParamClasses]
}

newExecutorActionPropertyDefinitionBody ::= NEWEXECUTOR actionPropertyDefinitionBody THREADS propertyExpression
{
    pin = 1
    implements="com.lsfusion.lang.psi.context.ActionExpression"
    methods = [inferActionParamClasses]
}

newSessionActionPropertyDefinitionBody ::= (    NEWSESSION (NEWSQL)? nestedPropertiesSelector? 
                                           |    NESTEDSESSION
                                           )
                                           (SINGLE)?
                                           actionPropertyDefinitionBody
{
    pin = 1
    implements="com.lsfusion.lang.psi.context.ActionExpression"
    methods = [inferActionParamClasses]
}

nonEmptyPropertyUsageListWithIds ::= propertyUsageWithId (COMMA propertyUsageWithId)*

propertyUsageWithId ::= propertyUsage (EQUALS (ID | stringLiteral))? 

drillDownActionPropertyDefinitionBody ::= DRILLDOWN propertyExpression
{
    pin = 1
    implements="com.lsfusion.lang.psi.context.ActionExpression"
    methods = [inferActionParamClasses]
}

requestInputActionPropertyDefinitionBody ::= REQUEST typeId (INPUT | (ID)? actionPropertyDefinitionBody)
{
    pin = 1
    implements="com.lsfusion.lang.psi.context.ActionExpression"
    methods = [inferActionParamClasses]
}

activeFormActionPropertyDefinitionBody ::= ACTIVE FORM formUsage
{
    pin = 1
    implements="com.lsfusion.lang.psi.context.ActionExpression"
    methods = [inferActionParamClasses]
}

activateActionPropertyDefinitionBody ::= ACTIVATE ((FORM formUsage) | (TAB componentUsage FORM formUsage))
{
    pin = 1
    implements="com.lsfusion.lang.psi.context.ActionExpression, com.lsfusion.lang.psi.context.FormContext"
    methods = [inferActionParamClasses resolveFormDecl]
}

listActionPropertyDefinitionBody ::=    LBRACE
			                            listActionStatement*
		                                RBRACE
{
    pin = 1
    mixin="com.lsfusion.lang.psi.LSFListActionImpl"
    implements="com.lsfusion.lang.psi.LSFListAction, com.lsfusion.lang.psi.context.ActionExpression"
    methods = [inferActionParamClasses]
}

private nestedPropertiesSelector ::= NESTED (LOCAL | (LBRAC nonEmptyNoContextPropertyUsageList RBRAC))

private listActionStatement ::= (   actionPropertyDefinitionBody << semicolonIfNeeded >>  //  !} => ;
                                |   localDataPropertyDefinition SEMI
                                |   emptyStatement
                                )
{
    pin(".*") = 1
    recoverWhile = "list_action_statement_recover"
}

private list_action_statement_recover ::= !(ACTIVATE | ADDFORM | ADDOBJ | APPLY | CANCEL | ASSIGN | ASYNCUPDATE | BREAK | CASE | CHANGECLASS | CONFIRM | CUSTOM | DELETE
                                            | DRILLDOWN | EDITFORM | EMAIL | EVAL | EXEC | FOCUS | FOR | FORM | TRY | IF | IMPORT | LOADFILE | LOCAL | MESSAGE | MULTI | OPENFILE
                                            | READ | REQUEST | RETURN | SAVEFILE | SEEK | WHILE| WRITE
                                            | NEWEXECUTOR | NEWSESSION | NEWTHREAD | NESTEDSESSION
                                            | ID
                                            | SEMI
                                            | LBRACE
                                            | RBRACE
                                           )

localDataPropertyDefinition ::= LOCAL nestedLocalModifier simpleName EQUALS className LBRAC classNameList RBRAC
{
    pin = 1
    mixin="com.lsfusion.lang.psi.declarations.impl.LSFLocalPropDeclarationImpl"
    implements="com.lsfusion.lang.psi.declarations.LSFLocalPropDeclaration"
}

nestedLocalModifier ::= (NESTED (MANAGESESSION | NOMANAGESESSION)?)?

//Разбиваем правило, чтобы была возможность запинить по EXEC
execActionPropertyDefinitionBody ::= execActionPropertyDefinitionBody1 | execActionPropertyDefinitionBody2
{
    implements = "com.lsfusion.lang.psi.context.PropertyUsageContext, com.lsfusion.lang.psi.context.ActionExpression"
    methods = [ resolveParamClasses inferActionParamClasses getParamList ]
}
private execActionPropertyDefinitionBody1 ::= EXEC propertyObject LBRAC propertyExpressionList RBRAC {pin = 1}
//EXEC - последнее правило, которое может начинаться с ID, поэтому спокойно пиним
private execActionPropertyDefinitionBody2 ::= propertyObject LBRAC propertyExpressionList RBRAC {pin = 1}

//Разбиваем правило, чтобы была возможность запинить по ASSIGN
assignActionPropertyDefinitionBody ::= assignActionPropertyDefinitionBody1 | assignActionPropertyDefinitionBody2
{
    implements="com.lsfusion.lang.psi.context.ExtendParamContext, com.lsfusion.lang.psi.context.ActionExpression"
    methods = [ getContextModifier getContextInferrer inferActionParamClasses ]
}

private assignActionPropertyDefinitionBody1 ::= ASSIGN mappedPropertyExprParam ARROW propertyExpression (WHERE propertyExpression)? {pin = 1}
private assignActionPropertyDefinitionBody2 ::= mappedPropertyExprParam ARROW propertyExpression (WHERE propertyExpression)? {pin = 2}

tryActionPropertyDefinitionBody ::= TRY actionPropertyDefinitionBody ((FINALLY actionPropertyDefinitionBody) | CATCH)
{
    pin = 1
    implements="com.lsfusion.lang.psi.context.ActionExpression" methods = [inferActionParamClasses]
}

ifActionPropertyDefinitionBody ::= IF propertyExpression THEN actionPropertyDefinitionBody (ELSE actionPropertyDefinitionBody)?
{
    pin = 1
    implements="com.lsfusion.lang.psi.context.ActionExpression" methods = [inferActionParamClasses]
}

caseActionPropertyDefinitionBody ::= CASE (exclusiveOverrideOption)? (actionCaseBranchBody)+ (ELSE actionPropertyDefinitionBody)?
{
    pin = 1
    implements="com.lsfusion.lang.psi.context.ActionExpression"
    methods = [inferActionParamClasses]
}

actionCaseBranchBody ::= WHEN propertyExpression (THEN actionPropertyDefinitionBody) {pin(".*") = 1}

multiActionPropertyDefinitionBody ::= MULTI (exclusiveOverrideOption)? nonEmptyActionPDBList
{
    pin = 1
    implements="com.lsfusion.lang.psi.context.ActionExpression"
    methods = [inferActionParamClasses]
}

applyActionPropertyDefinitionBody ::= APPLY nestedPropertiesSelector? SINGLE? SERIALIZABLE? actionPropertyDefinitionBody
{
    pin = 1
    implements="com.lsfusion.lang.psi.context.ActionExpression"
    methods = [inferActionParamClasses]
}

cancelActionPropertyDefinitionBody ::= CANCEL nestedPropertiesSelector?
{
    pin = 1
    implements="com.lsfusion.lang.psi.context.ActionExpression"
    methods = [inferActionParamClasses]
}

forAddObjClause ::= ADDOBJ (paramDeclare EQUALS)? customClassUsage
{
    pin = 1
    implements="com.lsfusion.lang.psi.context.ClassParamDeclareContext"
    methods = [ resolveClass ensureClass ]
}

forActionPropertyDefinitionBody ::= forActionPropertyMainBody
		                            (ELSE actionPropertyDefinitionBody)?
{
    implements="com.lsfusion.lang.psi.context.ActionExpression"
    methods = [ inferActionParamClasses ]
}

forActionPropertyMainBody ::= FOR (propertyExpression (ORDER (DESC)? nonEmptyPropertyExpressionList)? )?
                              inlineOption
                              (forAddObjClause)?
                              DO actionPropertyDefinitionBody
{
    pin = 1
    implements="com.lsfusion.lang.psi.context.ExtendParamContext"
    methods = [ getContextModifier getContextInferrer ]
}
                                                       
whileActionPropertyDefinitionBody ::= WHILE (propertyExpression (ORDER (DESC)? nonEmptyPropertyExpressionList)? )?
		                              inlineOption
		                              (forAddObjClause)?
		                              DO actionPropertyDefinitionBody
{
    pin = 1
    implements="com.lsfusion.lang.psi.context.ExtendParamContext, com.lsfusion.lang.psi.context.ActionExpression"
    methods = [ getContextModifier getContextInferrer inferActionParamClasses ]
}

terminalFlowActionPropertyDefinitionBody ::= (BREAK | RETURN) SEMI
{
    implements="com.lsfusion.lang.psi.context.ActionExpression" methods = [inferActionParamClasses]
}

////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////// FORM STATEMENT /////////////////////////////
////////////////////////////////////////////////////////////////////////////////

formStatement ::=	(	formDecl
            		|	extendingFormDeclaration
		            )
                    (	formGroupObjectsList
                    |	formTreeGroupObjectList
                    |	formFiltersList
                    |	formPropertiesList
                    |	formHintsList
                    |	formEventsList
                    |	formFilterGroupDeclaration
                    |	formExtendFilterGroupDeclaration
                    |	formOrderByList
                    |	dialogFormDeclaration
                    |	editFormDeclaration
                    |   reportFilesDeclaration
                    )*
                    SEMI
{
    pin=1
    elementTypeFactory = "com.lsfusion.lang.psi.stubs.types.LSFStubElementTypeFactory.create"
    stubClass = "com.lsfusion.lang.psi.stubs.extend.ExtendFormStubElement"
    implements="com.lsfusion.lang.psi.extend.LSFFormExtend, com.lsfusion.lang.psi.context.FormContext"
    mixin="com.lsfusion.lang.psi.extend.impl.LSFFormExtendImpl"
    methods = [resolveFormDecl]
}

dialogFormDeclaration ::= DIALOG customClassUsage OBJECT objectUsage {pin = 1}
editFormDeclaration ::= EDIT customClassUsage OBJECT objectUsage {pin = 1}

reportFilesDeclaration ::= REPORTFILES groupObjectReportPath (COMMA groupObjectReportPath)* {pin = 1}
groupObjectReportPath ::= (TOP | groupObjectUsage) formPropertyObject

formDecl ::= FORM simpleNameWithCaption
		            (   modalityTypeLiteral
		            |   IMAGE stringLiteral
		            |   AUTOREFRESH intLiteral
		            )*
{
    pin = 2
    mixin ="com.lsfusion.lang.psi.declarations.impl.LSFFormDeclarationImpl"
    implements="com.lsfusion.lang.psi.declarations.LSFFormDeclaration"
    stubClass = "com.lsfusion.lang.psi.stubs.FormStubElement"
    elementTypeFactory = "com.lsfusion.lang.psi.stubs.types.LSFStubElementTypeFactory.create"
}

extendingFormDeclaration ::= EXTEND FORM formUsageWrapper

formUsageWrapper ::= formUsage // for usages search filter

formGroupObjectsList ::= OBJECTS formGroupObjectDeclaration (COMMA formGroupObjectDeclaration)* {pin = 1}

formTreeGroupObjectList ::= TREE (treeGroupDeclaration)? formTreeGroupObjectDeclaration (COMMA formTreeGroupObjectDeclaration)* {pin = 1}

treeGroupDeclaration ::= simpleName
{
    implements="com.lsfusion.lang.psi.declarations.LSFTreeGroupDecl"
    mixin="com.lsfusion.lang.psi.declarations.impl.LSFTreeGroupDeclImpl"
}

formGroupObjectDeclaration ::= formCommonGroupObject formGroupObjectOptions
formGroupObjectOptions ::= (    formGroupObjectViewType 
                           |    formGroupObjectPageSize
                           |    formGroupObjectUpdate
                           |    formGroupObjectRelativePosition
                           )*
                           
formTreeGroupObjectDeclaration ::= formCommonGroupObject (treeGroupParentDeclaration)?
{implements = "com.lsfusion.lang.psi.context.PropertyUsageContext" methods = [ resolveParamClasses getParamList ]}

treeGroupParentDeclaration ::= PARENT (propertyUsage | LBRAC nonEmptyPropertyUsageList RBRAC) { pin = 1 }

formCommonGroupObject ::= formSingleGroupObjectDeclaration | formMultiGroupObjectDeclaration
{mixin="com.lsfusion.lang.psi.declarations.impl.LSFGroupObjectDeclarationImpl" implements="com.lsfusion.lang.psi.declarations.LSFGroupObjectDeclaration"}

formGroupObjectViewType ::= (INIT | FIXED) classViewType

classViewType ::= PANEL | GRID

formGroupObjectPageSize ::= PAGESIZE intLiteral

formGroupObjectUpdate ::= FIRST | LAST | PREV

formGroupObjectRelativePosition ::= AFTER groupObjectUsage | BEFORE groupObjectUsage  

formSingleGroupObjectDeclaration ::= formObjectDeclaration

formMultiGroupObjectDeclaration ::= (simpleName EQUALS)?
		                            LBRAC
			                        formObjectDeclaration (COMMA formObjectDeclaration)+
		                            RBRAC

formObjectDeclaration ::= (simpleName EQUALS)?
		                  className (localizedStringLiteral)?
		                  (ON CHANGE formActionPropertyObject)?
{
    mixin="com.lsfusion.lang.psi.declarations.impl.LSFObjectDeclarationImpl"
    implements="com.lsfusion.lang.psi.declarations.LSFObjectDeclaration"
}

formPropertyDrawNameDecl ::= (simpleName EQUALS)? formPropertyName formPropertyOptionsList
{
    mixin="com.lsfusion.lang.psi.declarations.impl.LSFPropertyDrawNameDeclarationImpl"
    implements="com.lsfusion.lang.psi.declarations.LSFPropertyDrawNameDeclaration"
}

formPropertiesNamesDeclList ::=	formPropertyDrawNameDecl (COMMA formPropertyDrawNameDecl)*

formPropertiesList ::=  PROPERTIES (formMappedNamePropertiesList | formPropertyOptionsList formMappedPropertiesList) { pin = 1 }

formMappedNamePropertiesList ::= LBRAC objectUsageList RBRAC formPropertyOptionsList formPropertiesNamesDeclList
{
    pin = 1
    implements = "com.lsfusion.lang.psi.context.PropertyUsageContext"
    methods = [ resolveParamClasses getParamList]
}

formPropertyOptionsList ::= (    EDITABLE
                            |    READONLY
                            |    SELECTOR
                            |    (NEWSESSION | NESTEDSESSION)
                            |    HINTNOUPDATE
                            |    HINTTABLE
                            |    OPTIMISTICASYNC
                            |    formOptionToolbar
                            |    formOptionForce
                            |    formOptionToDraw
                            |    formOptionEventId
                            |    formOptionColumns
                            |    formOptionsWithCalcPropertyObject
                            |    formOptionsWithFormPropertyDraw
                            |    formOptionsOnEvents
                            )*

formOptionToolbar ::= TOOLBAR
formOptionColumns ::= COLUMNS (stringLiteral)? LBRAC nonEmptyGroupObjectUsageList RBRAC {pin = 1}
formOptionForce ::= FORCE classViewType {pin = 1}
formOptionToDraw ::= TODRAW groupObjectUsage {pin = 1}
formOptionEventId ::= EVENTID stringLiteral {pin = 1}
formOptionsWithCalcPropertyObject ::= (SHOWIF | READONLYIF | BACKGROUND | FOREGROUND | HEADER | FOOTER) formCalcPropertyObject {pin = 1}
formOptionsWithFormPropertyDraw ::= (BEFORE | AFTER | QUICKFILTER) formPropertyDrawUsage {pin = 1}
formOptionsOnEvents ::= ON (formEventType | (SHORTCUT (localizedStringLiteral)?) ) formActionPropertyObject
{
    pin = 1
}

formCalcPropertyObject ::= formPropertyObject
formActionPropertyObject ::= formPropertyObject

formPropertyDrawMappedDecl ::= (simpleName EQUALS)? formPropertyObject formPropertyOptionsList
{
    mixin="com.lsfusion.lang.psi.declarations.impl.LSFPropertyDrawMappedDeclarationImpl"
    implements="com.lsfusion.lang.psi.declarations.LSFPropertyDrawMappedDeclaration"
}

formMappedPropertiesList ::= formPropertyDrawMappedDecl (COMMA formPropertyDrawMappedDecl)* {pin = 1}

formFiltersList ::= FILTERS formFilterDeclaration (COMMA formFilterDeclaration)* {pin(".*") = 1}

formHintsList ::= (HINTNOUPDATE | HINTTABLE) LIST nonEmptyNoContextPropertyUsageList {pin = 1}

formEventsList ::= EVENTS formEventDeclaration (COMMA formEventDeclaration)* {pin = 1}

formEventDeclaration ::= ON
                        (    OK
                        |    APPLY (BEFORE | AFTER)
                        |    CLOSE
                        |    INIT
                        |    CANCEL
                        |    DROP
                        |    QUERYOK
                        |    QUERYCLOSE
                        |    CHANGE ID
                        )
                        formActionPropertyObject
{
    pin = 1
}

formFilterGroupDeclaration ::= FILTERGROUP filterGroupName regularFilterDeclaration*
{pin = 1}

filterGroupName ::= simpleName
{
    mixin="com.lsfusion.lang.psi.declarations.impl.LSFFilterGroupDeclarationImpl"
    implements="com.lsfusion.lang.psi.declarations.LSFFilterGroupDeclaration"
}

formExtendFilterGroupDeclaration ::= EXTEND FILTERGROUP filterGroupUsage regularFilterDeclaration+
{pin(".*") = 1}

filterGroupUsage ::= simpleName
{
    mixin="com.lsfusion.lang.psi.references.impl.LSFFilterGroupReferenceImpl"
    implements="com.lsfusion.lang.psi.references.LSFFilterGroupReference"
}

regularFilterDeclaration ::= FILTER localizedStringLiteral formFilterDeclaration (stringLiteral)? (filterSetDefault)?

formFilterDeclaration ::= propertyExpression
filterSetDefault ::= DEFAULT

formOrderByList ::= ORDER BY formPropertyDrawWithOrder (COMMA formPropertyDrawWithOrder)* {pin(".*") = 1}

formPropertyDrawWithOrder ::= formPropertyDrawUsage (DESC)?

predefinedFormPropertyName ::= OBJVALUE
                           |    SELECTION
                           |   ((    ADDOBJ
                               |    ADDFORM
                               |    ADDNESTEDFORM
                               |    ADDSESSIONFORM) (LSQBR explicitPropClass RSQBR)?)
                           |    EDITFORM
                           |    EDITNESTEDFORM
                           |    EDITSESSIONFORM
                           |    DELETE
                           |    DELETESESSION
{
    mixin="com.lsfusion.lang.psi.LSFIdImpl"
    implements="com.lsfusion.lang.psi.LSFId"
}

formPropertyName ::= propertyUsage | predefinedFormPropertyName

formPropertyObject ::= formPropertyName LBRAC objectUsageList RBRAC
{
    pin = 1
    implements = "com.lsfusion.lang.psi.context.PropertyUsageContext"
    methods = [ resolveParamClasses getParamList ]
}

aliasUsage ::= simpleName

formPropertyDrawPropertyUsage ::= simpleName

formPropertyDrawUsage ::= (<< notSimpleIdAhead >> formPropertyDrawPropertyUsage LBRAC objectUsageList RBRAC) | aliasUsage
{
    implements="com.lsfusion.lang.psi.references.LSFPropertyDrawReference"
    mixin="com.lsfusion.lang.psi.references.impl.LSFPropertyDrawReferenceImpl"
}

////////////////////////////////////////////////////////////////////////////////
/////////////////////////////OVERRIDE STATEMENT/////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

overrideStatement ::= mappedPropertyClassParamDeclare PLUSEQ
		                (WHEN propertyExpression THEN)?
		                (	propertyExpression
		                |	ACTION topActionPropertyDefinitionBody
		                )
		                << semicolonIfNeeded >>
{
    pin = 2;
    implements="com.lsfusion.lang.psi.context.ModifyParamContext"
    methods = [ getContextModifier getContextInferrer getIcon ]
}

////////////////////////////////////////////////////////////////////////////////
//////////////////////////////// CONSTRAINT STATEMENT //////////////////////////
////////////////////////////////////////////////////////////////////////////////

constraintStatement ::= CONSTRAINT baseEvent propertyExpression
		                (CHECKED (BY nonEmptyNoContextPropertyUsageList)? )?
		                MESSAGE propertyExpression
		                SEMI
{
    pin = 1
    implements="com.lsfusion.lang.psi.context.ModifyParamContext"
    methods = [ getContextModifier getContextInferrer getIcon ]
}

////////////////////////////////////////////////////////////////////////////////
///////////////////////////////// FOLLOWS STATEMENT ////////////////////////////
////////////////////////////////////////////////////////////////////////////////

followsStatement ::= mappedPropertyClassParamDeclare FOLLOWS
                     propertyExpression (RESOLVE LEFT? RIGHT? baseEvent)?		             
		             SEMI
{
    pin = 2
    implements="com.lsfusion.lang.psi.context.ModifyParamContext"
    methods = [ getContextModifier getContextInferrer getIcon ]
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////// WRITE STATEMENT /////////////////////////////
////////////////////////////////////////////////////////////////////////////////

writeWhenStatement ::= mappedPropertyClassParamDeclare ARROW propertyExpression WHEN (DO)? propertyExpression SEMI
{
    pin = 2
    implements="com.lsfusion.lang.psi.context.ModifyParamContext"
    methods = [ getContextModifier getContextInferrer getIcon ]
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////// EVENT STATEMENT /////////////////////////////
////////////////////////////////////////////////////////////////////////////////

eventStatement ::= WHEN baseEvent propertyExpression inlineOption
		                DO actionPropertyDefinitionBody (ORDER (DESC)? nonEmptyPropertyExpressionList)?
		           << semicolonIfNeeded >>
{
    pin = 1
    implements="com.lsfusion.lang.psi.context.ModifyParamContext"
    methods = [ getContextModifier getContextInferrer getIcon ]
}

////////////////////////////////////////////////////////////////////////////////
//////////////////////////// GLOBAL EVENT STATEMENT ////////////////////////////
////////////////////////////////////////////////////////////////////////////////

globalEventStatement ::= ON baseEvent (SINGLE)? (SHOWDEP ID)? actionPropertyDefinitionBody << semicolonIfNeeded >>
{
    pin=1
    implements="com.lsfusion.lang.psi.context.ModifyParamContext"
    methods = [ getContextModifier getContextInferrer getIcon ]
}

baseEvent ::= (GLOBAL | SESSION)? (FORMS nonEmptyFormUsageList)? (GOAFTER nonEmptyNoContextPropertyUsageList)?

inlineOption ::=   (NOINLINE (LBRAC exprParameterUsageList RBRAC)? )? (INLINE)?

////////////////////////////////////////////////////////////////////////////////
//////////////////////////////// SHOWDEP STATEMENT //////////////////////////////
////////////////////////////////////////////////////////////////////////////////

showDepStatement ::= SHOWDEP noContextPropertyUsage FROM noContextPropertyUsage SEMI {pin=1 methods = [ getIcon ]}

////////////////////////////////////////////////////////////////////////////////
//////////////////////////////// ASPECT STATEMENT //////////////////////////////
////////////////////////////////////////////////////////////////////////////////

aspectStatement ::= (BEFORE | AFTER) mappedPropertyClassParamDeclare DO actionPropertyDefinitionBody << semicolonIfNeeded >>
{
    pin=1
    implements="com.lsfusion.lang.psi.context.ModifyParamContext"
    methods = [ getContextModifier getContextInferrer getIcon ]
}


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////// TABLE STATEMENT /////////////////////////////
////////////////////////////////////////////////////////////////////////////////

tableStatement ::= TABLE simpleName LBRAC nonEmptyClassNameList RBRAC (FULL)? SEMI 
{
    pin = 2
    mixin="com.lsfusion.lang.psi.declarations.impl.LSFTableDeclarationImpl"
    implements="com.lsfusion.lang.psi.declarations.LSFTableDeclaration"
    stubClass = "com.lsfusion.lang.psi.stubs.TableStubElement"
    elementTypeFactory = "com.lsfusion.lang.psi.stubs.types.LSFStubElementTypeFactory.create"
}


////////////////////////////////////////////////////////////////////////////////
/////////////////////////////// LOGGABLE STATEMENT /////////////////////////////
////////////////////////////////////////////////////////////////////////////////

loggableStatement ::= LOGGABLE nonEmptyNoContextPropertyUsageList SEMI {pin=1 methods = [ getIcon ]}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////// INDEX STATEMENT /////////////////////////////
////////////////////////////////////////////////////////////////////////////////

mappedPropertyOrSimpleExprParam ::= mappedPropertyExprParam | exprParameterUsage; // exprParam
nonEmptyMappedPropertyOrSimpleExprParamList ::= mappedPropertyOrSimpleExprParam (COMMA mappedPropertyOrSimpleExprParam)*  { pin(".*") = 1}

indexStatement ::= INDEX nonEmptyMappedPropertyOrSimpleExprParamList SEMI {
    implements="com.lsfusion.lang.psi.context.ModifyParamContext"
    methods = [ getContextModifier getContextInferrer ]
    pin=1 methods = [ getIcon ]
}

////////////////////////////////////////////////////////////////////////////////
/////////////////////////////// WINDOW STATEMENT ////////////////////////////
////////////////////////////////////////////////////////////////////////////////

windowStatement ::= windowCreateStatement | windowHideStatement {pin=1 methods = [ getIcon ]}

windowCreateStatement ::= WINDOW simpleName (localizedStringLiteral)? windowType windowOptions SEMI
{mixin="com.lsfusion.lang.psi.declarations.impl.LSFWindowDeclarationImpl" implements="com.lsfusion.lang.psi.declarations.LSFWindowDeclaration"
    stubClass = "com.lsfusion.lang.psi.stubs.WindowStubElement"
    elementTypeFactory = "com.lsfusion.lang.psi.stubs.types.LSFStubElementTypeFactory.create"
    pin = 2
}

windowHideStatement ::= HIDE WINDOW windowUsage SEMI {pin=2}

windowType ::= MENU | PANEL | TOOLBAR | TREE

windowOptions ::=   (	HIDETITLE
                    |	DRAWROOT
                    |	HIDESCROLLBARS
                    |	orientation
                    |	dockPosition
                    |	borderPosition
                    |	HALIGN LBRAC alignmentLiteral RBRAC
                    |	VALIGN LBRAC alignmentLiteral RBRAC
                    |	TEXTHALIGN LBRAC alignmentLiteral RBRAC
                    |	TEXTVALIGN LBRAC alignmentLiteral RBRAC
                    )*

borderPosition ::= LEFT	| RIGHT | TOP | BOTTOM
orientation ::= VERTICAL | HORIZONTAL
dockPosition ::= POSITION LBRAC intLiteral COMMA intLiteral COMMA intLiteral COMMA intLiteral RBRAC

////////////////////////////////////////////////////////////////////////////////
/////////////////////////////// NAVIGATOR STATEMENT ////////////////////////////
////////////////////////////////////////////////////////////////////////////////

navigatorStatement ::= NAVIGATOR navigatorElementStatementBody {pin=1 methods = [ getIcon ]}

navigatorElementStatementBody ::=   (   LBRACE
                                        (	addNavigatorElementStatement
                                        |	newNavigatorElementStatement
                                        |	setupNavigatorElementStatement
                                        |	emptyStatement
                                        )*
                                        RBRACE
                                    ) | emptyStatement

addNavigatorElementStatement ::= ADD navigatorElementSelector (localizedStringLiteral)? navigatorElementOptions navigatorElementStatementBody
{
    pin = 1
}

newNavigatorElementStatement ::= NEW simpleName (localizedStringLiteral)? (ACTION noContextPropertyUsage)? navigatorElementOptions navigatorElementStatementBody
{
    pin = 2
    mixin="com.lsfusion.lang.psi.declarations.impl.LSFNavigatorElementDeclarationImpl"
    implements="com.lsfusion.lang.psi.declarations.LSFNavigatorElementDeclaration"
    stubClass = "com.lsfusion.lang.psi.stubs.NavigatorElementStubElement"
    elementTypeFactory = "com.lsfusion.lang.psi.stubs.types.LSFStubElementTypeFactory.create"
}

setupNavigatorElementStatement ::= navigatorElementSelector (localizedStringLiteral)? navigatorElementOptions navigatorElementStatementBody

navigatorElementOptions ::= (	WINDOW windowUsage
                            |	navigatorElementInsertPosition 
                            |	IMAGE stringLiteral
                            )*


navigatorElementInsertPosition ::=	(   insertRelativePositionLiteral navigatorElementSelector
                                    |	FIRST
                                    )

navigatorElementSelector ::= navigatorElementUsage

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////// DESIGN STATEMENT ////////////////////////////
////////////////////////////////////////////////////////////////////////////////

designStatement ::=	designHeader componentBody {
    pin = 1
    elementTypeFactory = "com.lsfusion.lang.psi.stubs.types.LSFStubElementTypeFactory.create"
    stubClass = "com.lsfusion.lang.psi.stubs.extend.DesignStubElement"
    implements="com.lsfusion.lang.psi.extend.LSFDesign, com.lsfusion.lang.psi.context.FormContext"
    mixin="com.lsfusion.lang.psi.extend.impl.LSFDesignImpl"
    methods = [ getIcon resolveFormDecl]
}

designHeader ::= DESIGN formUsage (localizedStringLiteral)? customFormDesignOption? {pin=2}

customFormDesignOption ::= CUSTOM

componentBody ::= componentBlockStatement | emptyStatement

componentBlockStatement ::= LBRACE componentStatement* RBRACE
{
    pin = 1
}

componentStatement ::=      setObjectPropertyStatement
                        |	setupComponentStatement
                        |	newComponentStatement
                        |   moveComponentStatement
                        |	removeComponentStatement
                        |	emptyStatement
                        |   componentStubStatement
{
    recoverWhile = "component_statement_recover"
}

private component_statement_recover ::= !component_statement_recover_start 
private component_statement_recover_start ::= ID | PARENT | PROPERTY | NEW | MOVE | REMOVE | SEMI | RBRACE 

componentStubStatement ::= NEW ID
{
    pin(".*") = 1
}

setupComponentStatement ::= componentSelector componentBody
{
    pin = 1
}

newComponentStatement ::= NEW componentStubDecl componentInsertPosition componentBody {pin = 2}
moveComponentStatement ::= MOVE componentSelector componentInsertPosition componentBody {pin = 1}

componentInsertPosition ::= (   insertRelativePositionLiteral componentSelector
                            |	FIRST
                            )?
                            
removeComponentStatement ::= REMOVE componentSelector SEMI {pin = 1}

componentSelector ::=   PARENT LBRAC componentSelector RBRAC
                	|	PROPERTY LBRAC propertySelector RBRAC
                    |	componentUsage
{
    pin(".*") = 1
}

componentStubDecl ::= componentDecl
{
    implements="com.lsfusion.lang.psi.declarations.LSFComponentStubDeclaration"
    mixin="com.lsfusion.lang.psi.declarations.impl.LSFComponentStubDeclarationImpl"
    stubClass = "com.lsfusion.lang.psi.stubs.ComponentStubElement"
    elementTypeFactory = "com.lsfusion.lang.psi.stubs.types.LSFStubElementTypeFactory.create"
}

componentDecl ::= multiCompoundID
{
    implements="com.lsfusion.lang.psi.declarations.LSFComponentDeclaration"
    mixin="com.lsfusion.lang.psi.declarations.impl.LSFComponentDeclarationImpl"
}

componentUsage ::= multiCompoundID
{
    implements="com.lsfusion.lang.psi.references.LSFComponentReference"
    mixin="com.lsfusion.lang.psi.references.impl.LSFComponentReferenceImpl"
}

propertySelector ::= formPropertyDrawUsage

setObjectPropertyStatement ::= ID EQUALS componentPropertyValue SEMI {pin = 2}

componentPropertyValue ::=  colorLiteral
                        |	stringLiteral
                        |	intLiteral
                        |	doubleLiteral
                        |	dimensionLiteral
                        |	booleanLiteral
                        |	boundsIntLiteral
                        |	boundsDoubleLiteral
                        |   containerTypeLiteral
                        |   flexAlignmentLiteral
                        |   formCalcPropertyObject

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////// META STATEMENT //////////////////////////////
////////////////////////////////////////////////////////////////////////////////

metaCodeDeclarationStatement ::= META simpleName LBRAC metaDeclIdList RBRAC anyTokens END {
    pin=2
    mixin = "com.lsfusion.lang.psi.declarations.impl.LSFMetaDeclarationImpl"
    implements = "com.lsfusion.lang.psi.declarations.LSFMetaDeclaration"
    stubClass = "com.lsfusion.lang.psi.stubs.MetaStubElement"
    elementTypeFactory = "com.lsfusion.lang.psi.stubs.types.LSFStubElementTypeFactory.create"
}

anyTokens ::= (<< readAny >>)*

private metaStatement ::= statement { recoverWhile = "meta_statement_recover" }
private meta_statement_recover ::= !(statement_start | RBRACE)
metaCodeBody ::= metaCodeBodyLeftBrace (metaStatement*) metaCodeBodyRightBrace

metaCodeBodyLeftBrace ::= LBRACE
metaCodeBodyRightBrace ::= RBRACE

metaCodeStatement ::= metaCodeStatementHeader metaCodeBody? metaCodeStatementSemi
{
    pin=2
    mixin="com.lsfusion.lang.psi.references.impl.LSFMetaReferenceImpl"
    implements="com.lsfusion.lang.psi.references.LSFMetaReference"
}

metaCodeStatementHeader ::= ATSIGN metacodeUsage LBRAC metaCodeIdList RBRAC
metaCodeStatementSemi ::= SEMI

metaDeclId ::=  ID
metaDeclIdList ::= metaDeclId (COMMA metaDeclId)*

metaCodeIdList ::= (metaCodeId (COMMA metaCodeId)*)?

metaCodeId ::= (PRIMITIVE_TYPE | compoundID | metaCodeLiteral)?

metaCodeLiteral ::= LEX_STRING_LITERAL
                | 	LEX_UINT_LITERAL
                |	LEX_UNUMERIC_LITERAL
                |	LEX_UDOUBLE_LITERAL
                |	LEX_ULONG_LITERAL
                |	LEX_LOGICAL_LITERAL
                |	LEX_DATE_LITERAL
                |	LEX_DATETIME_LITERAL
                |	LEX_TIME_LITERAL
                |	LEX_COLOR_LITERAL
                |	NULL

////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////// COMMON /////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

emptyStatement ::= SEMI;

mappedPropertyClassParamDeclare ::= propertyUsageWrapper LBRAC classParamDeclareList RBRAC // temporary domain logic
{
    pin = 1
    implements = "com.lsfusion.lang.psi.context.PropertyUsageContext"
    methods = [ resolveParamClasses getParamList ]
}

propertyUsageWrapper ::= propertyUsage // for usages search filter

mappedPropertyExprParam ::= propertyUsage LBRAC exprParameterUsageList RBRAC // temporary mixed logic
{
    implements = "com.lsfusion.lang.psi.context.PropertyUsageContext"
    methods = [ resolveParamClasses getParamList]
}

simpleNameWithCaption ::= simpleName (localizedStringLiteral)?

// local

objectUsageList ::= (nonEmptyObjectUsageList)?
nonEmptyObjectUsageList ::= objectUsage (COMMA objectUsage)*

nonEmptyGroupObjectUsageList ::= groupObjectUsage (COMMA groupObjectUsage)*

// global
nonEmptyCustomClassUsageList ::= customClassUsage (COMMA customClassUsage)*  { pin(".*") = 1}

nonEmptyModuleUsageList ::= moduleUsage (COMMA moduleUsage)* { pin(".*") = 1}

nonEmptyNamespaceUsageList ::= namespaceUsage (COMMA namespaceUsage)*  { pin(".*") = 1}

classNameList ::= (nonEmptyClassNameList)?
nonEmptyClassNameList ::= className (COMMA className)* { pin(".*") = 1}

nonEmptyPropertyUsageList ::= propertyUsage (COMMA propertyUsage)*  { pin(".*") = 1}

nonEmptyNoContextPropertyUsageList ::= noContextPropertyUsage (COMMA noContextPropertyUsage)*  { pin(".*") = 1}

nonEmptyFormUsageList ::= formUsage (COMMA formUsage)*  { pin(".*") = 1}

exprParameterUsageList ::= (exprParameterUsage (COMMA exprParameterUsage)*)? { pin(".*") = 1}

nonEmptyActionPDBList ::= actionPropertyDefinitionBody (COMMA actionPropertyDefinitionBody)* { pin(".*") = 1}

propertyExpressionList ::= (nonEmptyPropertyExpressionList)?
nonEmptyPropertyExpressionList ::= propertyExpression (COMMA propertyExpression)* { pin(".*") = 1}

literal ::=
        ulongLiteral
	|	uintLiteral
	|	udoubleLiteral
	|	unumericLiteral
	|	localizedStringLiteral
	|	booleanLiteral
	|	dateTimeLiteral
	|	dateLiteral
	|	timeLiteral
	|	nullLiteral
	|	staticObjectID
	|	colorLiteral
{implements = "com.lsfusion.lang.psi.context.LSFExpression" methods = [ resolveInferredValueClass inferParamClasses getValueClassNames getValuePropertyNames ]}

builtInClassName ::= PRIMITIVE_TYPE
{
    mixin="com.lsfusion.lang.psi.LSFIdImpl"
    implements="com.lsfusion.lang.psi.LSFId"
}

className ::= builtInClassName | customClassUsage

// local

// parameterUsage is not needed yet, there is either declaration (mappedPropertyParamDeclare), or exprUsage (exprParameterUsage) 

objectUsage ::= simpleName
{mixin="com.lsfusion.lang.psi.references.impl.LSFObjectReferenceImpl" implements="com.lsfusion.lang.psi.references.LSFObjectReference"}

groupObjectUsage ::= simpleName
{mixin="com.lsfusion.lang.psi.references.impl.LSFGroupObjectReferenceImpl" implements="com.lsfusion.lang.psi.references.LSFGroupObjectReference"}

exprParameterNameUsage ::= classParamDeclare
{mixin="com.lsfusion.lang.psi.references.impl.LSFExprParamReferenceImpl" implements="com.lsfusion.lang.psi.references.LSFExprParamReference"}

// can be used for param and object simultaneously, for use in exprs
exprParameterUsage ::= (DOLLAR)? exprParameterNameUsage

// global

customClassUsage ::= compoundID
{mixin="com.lsfusion.lang.psi.references.impl.LSFClassReferenceImpl" implements="com.lsfusion.lang.psi.references.LSFClassReference"}

moduleUsage ::= simpleName
{mixin="com.lsfusion.lang.psi.references.impl.LSFModuleReferenceImpl" implements="com.lsfusion.lang.psi.references.LSFModuleReference"}

namespaceUsage ::= simpleName
{mixin="com.lsfusion.lang.psi.references.impl.LSFNamespaceReferenceImpl" implements="com.lsfusion.lang.psi.references.LSFNamespaceReference"}

explicitPropClass ::= className | QUESTION 

nonEmptyExplicitPropClassList ::= explicitPropClass (COMMA explicitPropClass)*
emptyExplicitPropClassList ::= nonEmptyExplicitPropClassList?
explicitPropClassUsage ::= LSQBR emptyExplicitPropClassList RSQBR
propertyUsage ::= compoundID explicitPropClassUsage?
{mixin="com.lsfusion.lang.psi.references.impl.LSFPropReferenceImpl" implements="com.lsfusion.lang.psi.references.LSFPropReference"}

tableUsage ::= compoundID
{mixin="com.lsfusion.lang.psi.references.impl.LSFTableReferenceImpl" implements="com.lsfusion.lang.psi.references.LSFTableReference"}

groupUsage ::= compoundID
{mixin="com.lsfusion.lang.psi.references.impl.LSFGroupReferenceImpl" implements="com.lsfusion.lang.psi.references.LSFGroupReference"}

formUsage ::= compoundID
{mixin="com.lsfusion.lang.psi.references.impl.LSFFormReferenceImpl" implements="com.lsfusion.lang.psi.references.LSFFormReference"}

windowUsage ::= compoundID
{mixin="com.lsfusion.lang.psi.references.impl.LSFWindowReferenceImpl" implements="com.lsfusion.lang.psi.references.LSFWindowReference"}

navigatorElementUsage ::= compoundID
{mixin="com.lsfusion.lang.psi.references.impl.LSFNavigatorElementReferenceImpl" implements="com.lsfusion.lang.psi.references.LSFNavigatorElementReference"}

metacodeUsage ::= compoundID

typeId ::= PRIMITIVE_TYPE | OBJECT

compoundID ::= (<<innerIDStop>> namespaceUsage POINT simpleName) | simpleName

staticObjectID ::= <<fullCompoundParamDeclareStop>> <<innerIDCheck>> customClassUsage POINT simpleName
{mixin="com.lsfusion.lang.psi.references.impl.LSFStaticObjectReferenceImpl" implements="com.lsfusion.lang.psi.references.LSFStaticObjectReference"}

groupObjectID ::= <<innerIDCheck>> formUsage POINT groupObjectUsage
{
    pin = 3
    implements="com.lsfusion.lang.psi.context.FormContext"
    methods = [resolveFormDecl]
}

objectID ::= <<innerIDCheck>> formUsage POINT objectUsage
{
    pin = 3
    implements="com.lsfusion.lang.psi.context.FormContext"
    methods = [resolveFormDecl]
}

formPropertyDrawID ::= <<innerIDCheck>> formUsage POINT formPropertyDrawUsage
{
    pin = 3
    implements="com.lsfusion.lang.psi.context.FormContext"
    methods = [resolveFormDecl]
}

multiCompoundID ::= ID (POINT ID)*
{
    mixin="com.lsfusion.lang.psi.LSFIdImpl"
    implements="com.lsfusion.lang.psi.LSFId"
    methods = [ setName ]
}

exclusiveOverrideOption ::= OVERRIDE | EXCLUSIVE

abstractExclusiveOverrideOption ::= (OVERRIDE abstractCaseAddOption? ) | EXCLUSIVE

abstractCaseAddOption ::= FIRST | LAST

colorLiteral ::= LEX_COLOR_LITERAL | (RGB LBRAC uintLiteral COMMA uintLiteral COMMA uintLiteral RBRAC)
stringLiteral ::= LEX_STRING_LITERAL
{
    mixin="com.lsfusion.lang.psi.LSFStringValueLiteralImpl"
    implements="com.lsfusion.lang.psi.LSFStringValueLiteral"
}

localizedStringLiteral ::= LEX_STRING_LITERAL 
{
    mixin="com.lsfusion.lang.psi.LSFLocalizedStringValueLiteralImpl"
    implements="com.lsfusion.lang.psi.LSFLocalizedStringValueLiteral"
}
intLiteral ::= (MINUS)? uintLiteral
doubleLiteral ::= (MINUS)? unumericLiteral
dateLiteral ::= LEX_DATE_LITERAL
dateTimeLiteral ::= LEX_DATETIME_LITERAL
timeLiteral ::= LEX_TIME_LITERAL
booleanLiteral ::= LEX_LOGICAL_LITERAL
udoubleLiteral ::= LEX_UDOUBLE_LITERAL
unumericLiteral ::= LEX_UNUMERIC_LITERAL
uintLiteral ::= LEX_UINT_LITERAL
ulongLiteral ::= LEX_ULONG_LITERAL
nullLiteral ::= NULL
codeLiteral ::= LEX_CODE_LITERAL

nullOption ::= NULL

equalsSign ::= EQUALS

dimensionLiteral ::= LBRAC intLiteral COMMA intLiteral RBRAC
boundsIntLiteral ::= LBRAC intLiteral COMMA intLiteral COMMA intLiteral COMMA intLiteral RBRAC
boundsDoubleLiteral ::= LBRAC doubleLiteral COMMA doubleLiteral COMMA doubleLiteral COMMA doubleLiteral RBRAC

insertRelativePositionLiteral ::= BEFORE | AFTER

containerTypeLiteral ::=    CONTAINERV
	                    |	CONTAINERH
	                    |	COLUMNS
	                    |	TABBED
	                    |   SCROLL
	                    |	SPLITH
	                    |	SPLITV
	                    
alignmentLiteral ::= LEADING | CENTER | TRAILING

flexAlignmentLiteral ::= LEADING | CENTER | TRAILING | STRETCH

modalityTypeLiteral ::= DOCKED | MODAL | DOCKEDMODAL | FULLSCREEN | DIALOG

formPrintTypeLiteral ::= PRINT (AUTO | XLSX | XLS | PDF)? {pin = 1}

formExportLiteral ::= EXPORT (DOC | DOCX | PDF | XLS | XLSX) {pin = 1}

emailRecipientTypeLiteral ::= TO | CC | BCC

emailAttachFormat ::= PDF | DOCX | HTML | RTF | XLSX

