{
  psiImplUtilClass="com.lsfusion.lang.psi.LSFPsiImplUtil"

  parserClass="com.lsfusion.lang.parser.LSFParser"
  parserUtilClass="com.lsfusion.lang.parser.LSFParserUtil"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="LSF"
  psiImplClassSuffix="Impl"
  psiPackage="com.lsfusion.lang.psi"
  psiImplPackage="com.lsfusion.lang.psi.impl"
 
  elementTypeHolderClass="com.lsfusion.lang.psi.LSFTypes"
  elementTypeClass="com.lsfusion.lang.psi.LSFElementType"
  elementTypeFactory = "com.lsfusion.lang.psi.LSFElementTypeFactory.create"

  tokenTypeClass="com.lsfusion.lang.psi.LSFTokenType"

  extendedPin = false

  // additional tokens
  tokens = [
    COMMENTS='COMMENTS'
  ]
}

script ::= << isExpressionParsing >> propertyExpression
        | << isActionParsing >> listActionStatement*
        | moduleHeader lazyScriptStatement*

// with META lazyness there is a problem, that psi change detector works for whole lazy statement, however this change detector has been being deprecated, so we'll have to fix it some other way
lazyScriptStatement ::= scriptStatement* { lazy = true extends = "com.lsfusion.lang.psi.LSFLazyParsableElement" }

private statement ::= metaCodeDeclarationStatement | innerStatement
private statement_start ::= META | inner_statement_start

private script_statement_recover ::= !statement_start // it's last rule, so recover only to the statement start
scriptStatement ::= statement { recoverWhile = "script_statement_recover" }

simpleName ::= ID
{
    mixin="com.lsfusion.lang.psi.LSFIdImpl"
    implements="com.lsfusion.lang.psi.LSFId,com.intellij.psi.PsiNamedElement"
}

moduleHeader ::= moduleNameStatement
                 requireList?
                 priorityList?
                 namespaceName?
{
    pin = 2
    mixin="com.lsfusion.lang.psi.declarations.impl.LSFModuleDeclarationImpl"
    implements="com.lsfusion.lang.psi.declarations.LSFModuleDeclaration"
    methods = [getDocumentation]
    stubClass = "com.lsfusion.lang.psi.stubs.ModuleStubElement"
    elementTypeFactory = "com.lsfusion.lang.psi.stubs.types.LSFStubElementTypeFactory.create"
    recoverWhile = "script_statement_recover"
}

moduleName ::= simpleName;
moduleNameStatement ::= MODULE moduleName SEMI;
requireList ::= REQUIRE nonEmptyModuleUsageList SEMI {pin = 1};
priorityList ::= PRIORITY nonEmptyNamespaceUsageList SEMI {pin = 1};
namespaceName ::= NAMESPACE namespaceUsage SEMI
{
    pin = 2;
    mixin="com.lsfusion.lang.psi.declarations.impl.LSFExplicitNamespaceDeclarationImpl"
    implements="com.lsfusion.lang.psi.declarations.LSFExplicitNamespaceDeclaration"
    stubClass = "com.lsfusion.lang.psi.stubs.ExplicitNamespaceStubElement"
    elementTypeFactory = "com.lsfusion.lang.psi.stubs.types.LSFStubElementTypeFactory.create"
}

private innerStatement ::=   constraintStatement
                    |	groupStatement
                    |	overrideActionStatement // starts with ID
                    |	overridePropertyStatement // starts with ID
                    |	classStatement
                    |	followsStatement // starts with ID
                    |	writeWhenStatement // starts with ID
                    |	explicitInterfacePropertyStatement
                    |   explicitInterfaceActStatement
                    |	eventStatement
                    |	showDepStatement
                    |	globalEventStatement
                    |	aspectStatement
                    |	tableStatement
                    |	loggableStatement
                    |	indexStatement
                    |	formStatement
                    |	designStatement
                    |	windowStatement
                    |	navigatorStatement
                    |	metaCodeStatement // ?
                    |   internalStatement
                    |	emptyStatement
                    |   stubStatement
                    
internalStatement ::= INTERNAL (internalProperty | internalAction | internalClass | internalModule | internalPropertyDraw | internalFormObject) SEMI {pin = 1}
internalProperty ::= PROPERTY nonEmptyNoContextPropertyUsageList {pin = 1}
internalAction ::= ACTION nonEmptyNoContextActionUsageList {pin = 1}
internalClass ::= CLASS nonEmptyClassNameList {pin = 1}
internalModule ::= MODULE nonEmptyModuleUsageList {pin = 1}
internalPropertyDraw ::= PROPERTYDRAW formUsage formPropertyDrawUsage
{
    pin = 1
    implements="com.lsfusion.lang.psi.context.FormContext"
    methods = [resolveFormDecl]
}

internalFormObject ::= OBJECT formUsage objectUsage
{
    pin = 1
    implements="com.lsfusion.lang.psi.context.FormContext"
    methods = [resolveFormDecl]
}

// some statements are not pinned after the first token, so we need these fake rules to pin incomplete statements (to support recovery assertion) 
stubStatement ::=
    EXTEND (CLASS | FORM) ID
    | CLASS (ABSTRACT | NATIVE)? COMPLEX? ID
    | (ATSIGN | ATSIGN2 | FORM | GROUP | META | DESIGN | TABLE) ID
    | WINDOW windowType ID
    {pin(".*") = 1}

// Important ! after recover the rule should mandatory be pinned (matched)
private inner_statement_start ::= ID | AFTER | BEFORE | HIDE | INDEX | LOGGABLE | NAVIGATOR | ON | SHOWDEP | WHEN | CONSTRAINT | INTERNAL
                            | CLASS | ATSIGN | ATSIGN2 | FORM | GROUP | DESIGN | TABLE | WINDOW | EXTEND | SEMI


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////// CLASS STATEMENT /////////////////////////////
////////////////////////////////////////////////////////////////////////////////

classDecl ::= CLASS (ABSTRACT | NATIVE)? COMPLEX? simpleNameWithCaption
{
     pin = 1
     mixin = "com.lsfusion.lang.psi.declarations.impl.LSFClassDeclarationImpl"
     implements = "com.lsfusion.lang.psi.declarations.LSFClassDeclaration"
     methods = [getDocumentation]
     stubClass = "com.lsfusion.lang.psi.stubs.ClassStubElement"
     elementTypeFactory = "com.lsfusion.lang.psi.stubs.types.LSFStubElementTypeFactory.create"
}

extendingClassDeclaration ::= EXTEND CLASS customClassUsageWrapper
{
    pin = 2
    implements = "com.lsfusion.documentation.LSFDocumentation"
    methods = [ getDocumentation ]
}

customClassUsageWrapper ::= customClassUsage // for usages search filter

classStatement ::= (classDecl | extendingClassDeclaration) classInstancesAndParents
{
    pin = 1
    mixin="com.lsfusion.lang.psi.extend.impl.LSFClassExtendImpl"
    implements="com.lsfusion.lang.psi.extend.LSFClassExtend"
    methods = [ getDocumentation ]
    stubClass = "com.lsfusion.lang.psi.stubs.extend.ExtendClassStubElement"
    elementTypeFactory = "com.lsfusion.lang.psi.stubs.types.LSFStubElementTypeFactory.create"
}

private classInstancesAndParents ::=    LBRACE staticObjectDeclList RBRACE (classParentsList SEMI)? | (classParentsList)? SEMI {pin(".*") = 1}

classParentsList ::= COLON nonEmptyCustomClassUsageList {pin = 1}

staticObjectDeclList ::= (nonEmptyStaticObjectDeclList)?

nonEmptyStaticObjectDeclList ::= staticObjectDecl (COMMA staticObjectDecl)*

staticObjectDecl ::= simpleNameWithCaption
{mixin="com.lsfusion.lang.psi.declarations.impl.LSFStaticObjectDeclarationImpl" implements="com.lsfusion.lang.psi.declarations.LSFStaticObjectDeclaration"}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////// GROUP STATEMENT /////////////////////////////
////////////////////////////////////////////////////////////////////////////////

groupStatement ::= GROUP NATIVE? simpleNameWithCaption formExtID? (COLON groupUsage)? SEMI
{
    pin = 2
    implements="com.lsfusion.lang.psi.declarations.LSFGroupDeclaration"
    methods = [getDocumentation]
    mixin="com.lsfusion.lang.psi.declarations.impl.LSFGroupDeclarationImpl"
    stubClass = "com.lsfusion.lang.psi.stubs.GroupStubElement"
    elementTypeFactory = "com.lsfusion.lang.psi.stubs.types.LSFStubElementTypeFactory.create"
}


////////////////////////////////////////////////////////////////////////////////
//////////////////////////////// PROPERTY STATEMENT ////////////////////////////
////////////////////////////////////////////////////////////////////////////////

explicitInterfacePropertyStatement ::= explicitValuePropertyStatement
{
    mixin="com.lsfusion.lang.psi.declarations.impl.LSFExplicitInterfacePropStatementImpl"
    implements="com.lsfusion.lang.psi.declarations.LSFExplicitInterfacePropStatement"
    stubClass="com.lsfusion.lang.psi.stubs.interfaces.ExplicitInterfacePropStubElement"
    elementTypeFactory="com.lsfusion.lang.psi.stubs.types.LSFStubElementTypeFactory.create"
}

explicitValuePropertyStatement ::= implicitValuePropertyStatement
{
    mixin="com.lsfusion.lang.psi.declarations.impl.LSFExplicitValuePropStatementImpl"
    implements="com.lsfusion.lang.psi.declarations.LSFExplicitValuePropStatement"
    stubClass="com.lsfusion.lang.psi.stubs.interfaces.ExplicitValueStubElement"
    elementTypeFactory="com.lsfusion.lang.psi.stubs.types.LSFStubElementTypeFactory.create"
}

implicitValuePropertyStatement ::= implicitInterfacePropertyStatement
{
    mixin="com.lsfusion.lang.psi.declarations.impl.LSFImplicitValuePropStatementImpl"
    implements="com.lsfusion.lang.psi.declarations.LSFImplicitValuePropStatement"
    stubClass="com.lsfusion.lang.psi.stubs.interfaces.ImplicitValueStubElement"
    elementTypeFactory="com.lsfusion.lang.psi.stubs.types.LSFStubElementTypeFactory.create"
}

implicitInterfacePropertyStatement ::= propertyStatement
{
    mixin="com.lsfusion.lang.psi.declarations.impl.LSFImplicitInterfacePropStatementImpl"
    implements="com.lsfusion.lang.psi.declarations.LSFImplicitInterfacePropStatement"
    stubClass="com.lsfusion.lang.psi.stubs.interfaces.ImplicitInterfaceStubElement"
    elementTypeFactory="com.lsfusion.lang.psi.stubs.types.LSFStubElementTypeFactory.create"
}

propertyStatement ::= propertyDeclaration equalsSign propertyCalcStatement (nonEmptyPropertyOptions | SEMI)
{
    pin = 3
    mixin="com.lsfusion.lang.psi.declarations.impl.LSFStatementGlobalPropDeclarationImpl"
    implements="com.lsfusion.lang.psi.declarations.LSFStatementGlobalPropDeclaration,com.lsfusion.lang.psi.context.ModifyParamContext,com.lsfusion.lang.psi.LSFInterfacePropStatement"
    stubClass = "com.lsfusion.lang.psi.stubs.StatementPropStubElement"
    elementTypeFactory = "com.lsfusion.lang.psi.stubs.types.LSFStubElementTypeFactory.create"
    methods = [ getContextModifier getContextInferrer getDocumentation ]
}

explicitInterfaceActStatement ::= actionStatement
{
    mixin="com.lsfusion.lang.psi.declarations.impl.LSFExplicitInterfaceActionStatementImpl"
    implements="com.lsfusion.lang.psi.declarations.LSFExplicitInterfaceActionStatement"
    stubClass="com.lsfusion.lang.psi.stubs.interfaces.ExplicitInterfaceActionStubElement"
    elementTypeFactory="com.lsfusion.lang.psi.stubs.types.LSFStubElementTypeFactory.create"
}

actionStatement ::= propertyDeclaration
                        (   actionUnfriendlyPD (nonEmptyPropertyOptions | SEMI)
                        |   topActionPropertyDefinitionBody nonEmptyPropertyOptions?
                        )
{
    pin(".*") = 1
    mixin="com.lsfusion.lang.psi.declarations.impl.LSFActionDeclarationImpl"
    implements="com.lsfusion.lang.psi.declarations.LSFActionDeclaration,com.lsfusion.lang.psi.context.ModifyParamContext,com.lsfusion.lang.psi.LSFInterfacePropStatement"
    stubClass = "com.lsfusion.lang.psi.stubs.ActionStubElement"
    elementTypeFactory = "com.lsfusion.lang.psi.stubs.types.LSFStubElementTypeFactory.create"
    methods = [ getContextModifier getContextInferrer getDocumentation]
}

propertyCalcStatement ::= (expressionUnfriendlyPD | propertyExpression)

actionUnfriendlyPD ::= (abstractActionPropertyDefinition
                        |	customActionPropertyDefinitionBody
                        )
{
    methods = [ resolveValueParamClasses checkValueParamClasses ]
}

propertyDeclParams ::= LBRAC classParamDeclareList RBRAC

propertyDeclaration ::= simpleNameWithCaption propertyDeclParams?
{methods = [ resolveParamDecls ]}

paramDeclare ::= simpleName
{
    mixin="com.lsfusion.lang.psi.declarations.impl.LSFParamDeclarationImpl"
    implements="com.lsfusion.lang.psi.declarations.LSFParamDeclaration"
}

aggrParamPropDeclare ::= className paramDeclare
{
    mixin="com.lsfusion.lang.psi.declarations.impl.LSFAggrParamGlobalPropDeclarationImpl"
    implements="com.lsfusion.lang.psi.declarations.LSFAggrParamGlobalPropDeclaration"
    stubClass = "com.lsfusion.lang.psi.stubs.AggrParamPropStubElement"
    elementTypeFactory = "com.lsfusion.lang.psi.stubs.types.LSFStubElementTypeFactory.create"
}

untypedParamDeclare ::= paramDeclare

classParamDeclare ::= aggrParamPropDeclare | untypedParamDeclare
{
    implements="com.lsfusion.lang.psi.context.ClassParamDeclareContext"
    methods = [ resolveClass ensureClass getClassName getParamDeclare ]
}

classParamDeclareList ::= (nonEmptyClassParamDeclareList)?
nonEmptyClassParamDeclareList ::= classParamDeclare (COMMA classParamDeclare)*

propertyExpression ::= ifPE
{
    implements = "com.lsfusion.lang.psi.context.LSFExpression"
    methods = [ resolveValueClass resolveParams resolveAllParams resolveInferredValueClass inferParamClasses getValueClassNames getValuePropertyNames]
}

ifPE ::= orPE (IF orPE)*
{implements = "com.lsfusion.lang.psi.context.LSFExpression" methods = [ resolveInferredValueClass inferParamClasses getValueClassNames getValuePropertyNames getDocumentation]}

orPE ::= xorPE (OR xorPE)*
{implements = "com.lsfusion.lang.psi.context.LSFExpression" methods = [ resolveInferredValueClass inferParamClasses getValueClassNames getValuePropertyNames getDocumentation]}

xorPE ::= andPE (XOR andPE)*
{implements = "com.lsfusion.lang.psi.context.LSFExpression" methods = [ resolveInferredValueClass inferParamClasses getValueClassNames getValuePropertyNames getDocumentation]}

andPE ::= notPE (AND notPE)*
{implements = "com.lsfusion.lang.psi.context.LSFExpression" methods = [ resolveInferredValueClass inferParamClasses getValueClassNames getValuePropertyNames getDocumentation]}

notPE ::= (NOT notPE) | equalityPE
{implements = "com.lsfusion.lang.psi.context.LSFExpression" methods = [ resolveInferredValueClass inferParamClasses getValueClassNames getValuePropertyNames getDocumentation]}

equalityPE ::= relationalPE ((EQ_OPERAND | EQUALS) relationalPE)?
{implements = "com.lsfusion.lang.psi.context.LSFExpression" methods = [ resolveInferredValueClass inferParamClasses getValueClassNames getValuePropertyNames getDocumentation]}

relationalPE ::= likePE ((LESS | GREATER | LESS_EQUALS | GREATER_EQUALS) likePE)?
{implements = "com.lsfusion.lang.psi.context.LSFExpression" methods = [ resolveInferredValueClass inferParamClasses getValueClassNames getValuePropertyNames getDocumentation]}

likePE ::= additiveORPE (LIKE additiveORPE)?
{implements = "com.lsfusion.lang.psi.context.LSFExpression" methods = [ resolveInferredValueClass inferParamClasses getValueClassNames getValuePropertyNames getDocumentation]}

additiveORPE ::= additivePE (ADDOR_OPERAND additivePE)*
{implements = "com.lsfusion.lang.psi.context.LSFExpression" methods = [ resolveInferredValueClass inferParamClasses getValueClassNames getValuePropertyNames getDocumentation]}

additivePE ::= multiplicativePE ((PLUS | MINUS) multiplicativePE)*
{implements = "com.lsfusion.lang.psi.context.LSFExpression" methods = [ resolveInferredValueClass inferParamClasses getValueClassNames getValuePropertyNames getDocumentation]}

typeMult ::= MULT | DIV
multiplicativePE ::= unaryMinusPE (typeMult unaryMinusPE)*
{implements = "com.lsfusion.lang.psi.context.LSFExpression" methods = [ resolveInferredValueClass inferParamClasses getValueClassNames getValuePropertyNames getDocumentation]}

unaryMinusPE ::= (MINUS unaryMinusPE) | postfixUnaryPE
{implements = "com.lsfusion.lang.psi.context.LSFExpression" methods = [ resolveInferredValueClass inferParamClasses getValueClassNames getValuePropertyNames]}

postfixUnaryPE ::= simplePE ((LSQBR uintLiteral RSQBR) | typePropertyDefinition)?
{implements = "com.lsfusion.lang.psi.context.LSFExpression" methods = [ resolveInferredValueClass inferParamClasses getValueClassNames getValuePropertyNames]}

simplePE ::= (LBRAC propertyExpression RBRAC) | expressionPrimitive
{implements = "com.lsfusion.lang.psi.context.LSFExpression" methods = [ resolveInferredValueClass inferParamClasses getValueClassNames getValuePropertyNames]}

expressionPrimitive ::= <<fullCompoundParamDeclareCheck>> expressionFriendlyPD | exprParameterUsage
{implements = "com.lsfusion.lang.psi.context.LSFExpression" methods = [ resolveInferredValueClass inferParamClasses getValueClassNames getValuePropertyNames]}

expressionFriendlyPD ::= joinPropertyDefinition
	    |	multiPropertyDefinition
	    |	overridePropertyDefinition
	    |	ifElsePropertyDefinition
	    |	maxPropertyDefinition
	    |	casePropertyDefinition
	    |	partitionPropertyDefinition
	    |	groupExprPropertyDefinition
	    |	recursivePropertyDefinition
	    |	structCreationPropertyDefinition
	    |	concatPropertyDefinition
	    |	jsonPropertyDefinition
	    |	jsonFormPropertyDefinition
	    |	castPropertyDefinition
	    |	sessionPropertyDefinition
	    |	signaturePropertyDefinition
	    |   activeTabPropertyDefinition
	    |   roundPropertyDefinition
	    |	literal
{
    implements = "com.lsfusion.lang.psi.context.LSFExpression"
    methods = [ resolveInferredValueClass inferParamClasses getValueClassNames getValuePropertyNames ]
}

expressionUnfriendlyPD ::= dataPropertyDefinition
                           |   nativePropertyDefinition
                           |   abstractPropertyDefinition
                           |   formulaPropertyDefinition
                           |   groupPropertyDefinition
                           |   aggrPropertyDefinition
                           |   filterPropertyDefinition
                           |   reflectionPropertyDefinition
{methods = [ resolveUnfriendValueClass resolveValueParamClasses checkValueParamClasses]}

aggrPropertyDefinition ::= AGGR customClassUsage WHERE propertyExpression
{
    pin = 1;
    implements = "com.lsfusion.lang.psi.context.UnfriendlyPE"
    methods = [ resolveUnfriendValueClass resolveValueParamClasses checkValueParamClasses getValueParamClassNames getValueClassNames getValuePropertyNames getDocumentation]
} 

// для pin
private joinUsagePropertyDefinition ::= propertyUsage LBRAC propertyExpressionList RBRAC { pin = 2 }
private joinExprObjectPropertyDefinition ::= propertyExprObject LBRAC propertyExpressionList RBRAC { pin = 1 }

joinPropertyDefinition ::= JOIN? (joinUsagePropertyDefinition | joinExprObjectPropertyDefinition)
{
    pin = 3
    implements = "com.lsfusion.lang.psi.context.LSFExpression, com.lsfusion.lang.psi.context.PropertyUsageContext"
    methods = [ resolveInferredValueClass resolveParamClasses inferParamClasses getParamList getValueClassNames getValuePropertyNames ]
}

overrideOperator ::= OVERRIDE
{
    implements = "com.lsfusion.documentation.LSFDocumentation"
    methods = [getDocumentation]
}

exclusiveOperator ::= EXCLUSIVE
{
    implements = "com.lsfusion.documentation.LSFDocumentation"
    methods = [getDocumentation]
}
overridePropertyDefinition ::= (overrideOperator | exclusiveOperator) nonEmptyPropertyExpressionList
{pin = 1 implements = "com.lsfusion.lang.psi.context.LSFExpression" methods = [ resolveInferredValueClass inferParamClasses getValueClassNames getValuePropertyNames]}

ifElsePropertyDefinition ::= IF propertyExpression
                                    THEN propertyExpression
                                    (ELSE propertyExpression)?   // check greedy
{
    pin = 1
    implements = "com.lsfusion.lang.psi.context.LSFExpression"
    methods = [ resolveInferredValueClass inferParamClasses getValueClassNames getValuePropertyNames getDocumentation]
}

maxPropertyDefinition ::= (MAX | MIN) nonEmptyPropertyExpressionList
{
    pin = 1
    implements = "com.lsfusion.lang.psi.context.LSFExpression"
    methods = [ resolveInferredValueClass inferParamClasses getValueClassNames getValuePropertyNames getDocumentation]
}

caseBranchBody ::= WHEN propertyExpression (THEN propertyExpression) {pin(".*") = 1}
casePropertyDefinition ::= CASE (exclusiveOverrideOption)?
                           (caseBranchBody)+
                           (ELSE propertyExpression)?
{
    pin = 1
    implements = "com.lsfusion.lang.psi.context.LSFExpression"
    methods = [ resolveInferredValueClass inferParamClasses getValueClassNames getValuePropertyNames getDocumentation]
}

multiPropertyDefinition ::= MULTI (exclusiveOverrideOption)? nonEmptyPropertyExpressionList
{
    pin = 1
    implements = "com.lsfusion.lang.psi.context.LSFExpression"
    methods = [ resolveInferredValueClass inferParamClasses getValueClassNames getValuePropertyNames getDocumentation]
}

partitionPropertyBy ::= BY nonEmptyPropertyExpressionList
partitionPropertyDefinition ::= PARTITION
                                (   (SUM | PREV)
                                |   UNGROUP propertyUsage
                                    (   PROPORTION (STRICT)? ROUND LBRAC LEX_UINT_LITERAL RBRAC
                                    |   LIMIT (STRICT)?
                                    )
                                )
                                propertyExpression
                                (ORDER (DESC )? nonEmptyPropertyExpressionList)?
                                (WINDOW EXCEPTLAST)?
                                partitionPropertyBy?
{
    pin = 1
    implements = "com.lsfusion.lang.psi.context.LSFExpression, com.lsfusion.lang.psi.context.PropertyUsageContext"
    methods = [ resolveInferredValueClass resolveParamClasses inferParamClasses getParamList getValueClassNames getValuePropertyNames getDocumentation]
}

recursivePropertyDefinition ::= RECURSION propertyExpression STEP propertyExpression (CYCLES (YES |	NO | IMPOSSIBLE))?
{
    pin = 1
    implements = "com.lsfusion.lang.psi.context.LSFExpression"
    methods = [ resolveInferredValueClass inferParamClasses getValueClassNames getValuePropertyNames getDocumentation]
}

structCreationPropertyDefinition ::= STRUCT LBRAC nonEmptyPropertyExpressionList RBRAC
{
    pin = 1
    implements = "com.lsfusion.lang.psi.context.LSFExpression"
    methods = [ resolveInferredValueClass inferParamClasses getValueClassNames getValuePropertyNames getDocumentation]
}

castPropertyDefinition ::= builtInClassName LBRAC propertyExpression RBRAC
{implements = "com.lsfusion.lang.psi.context.LSFExpression" methods = [ resolveInferredValueClass inferParamClasses getValueClassNames getValuePropertyNames ]}

concatPropertyDefinition ::= CONCAT stringLiteral COMMA nonEmptyPropertyExpressionList
{pin = 1 implements = "com.lsfusion.lang.psi.context.LSFExpression" methods = [ resolveInferredValueClass inferParamClasses getValueClassNames getValuePropertyNames getDocumentation]}

jsonPropertyDefinition ::= JSON FROM nonEmptyAliasedPropertyExpressionList wherePropertyExpression? (ORDER propertyExpressionWithOrder (COMMA propertyExpressionWithOrder)*)?
{
    pin = 3
    implements = "com.lsfusion.lang.psi.context.LSFExpression, com.lsfusion.lang.psi.context.ExtendParamContext"
    methods = [ resolveInferredValueClass inferParamClasses getValueClassNames getValuePropertyNames getContextModifier getContextInferrer getDocumentation]
}

jsonFormPropertyDefinition ::= JSON LBRAC mappedForm contextFiltersClause? RBRAC
{
    pin = 1
    implements="com.lsfusion.lang.psi.context.LSFExpression, com.lsfusion.lang.psi.context.FormContext"
    methods = [resolveInferredValueClass inferParamClasses getValueClassNames getValuePropertyNames resolveFormDecl getDocumentation]
}

sessionPropertyType ::= PREV | CHANGED | SET | DROPPED | SETCHANGED | DROPCHANGED | SETDROPPED
sessionPropertyDefinition ::= sessionPropertyType LBRAC propertyExpression RBRAC
{pin = 1 implements = "com.lsfusion.lang.psi.context.LSFExpression" methods = [ resolveInferredValueClass inferParamClasses getValueClassNames getValuePropertyNames getDocumentation]}

signaturePropertyDefinition ::= (CLASS) LBRAC propertyExpression RBRAC
{implements = "com.lsfusion.lang.psi.context.LSFExpression" methods = [ resolveInferredValueClass inferParamClasses getValueClassNames getValuePropertyNames ]}

activeTabPropertyDefinition ::= ACTIVE TAB componentID
{
    pin = 1
    implements = "com.lsfusion.lang.psi.context.LSFExpression"
    methods = [ resolveInferredValueClass inferParamClasses getValueClassNames getValuePropertyNames getDocumentation]
}

roundPropertyDefinition ::= ROUND LBRAC propertyExpression (COMMA propertyExpression)? RBRAC
{
    implements = "com.lsfusion.lang.psi.context.LSFExpression"
    methods = [ resolveInferredValueClass inferParamClasses getValueClassNames getValuePropertyNames]
}

propertyExprObject ::= LSQBR (propertyCalcStatement) RSQBR
{ pin = 1 implements="com.lsfusion.lang.psi.context.ExtendParamContext" methods = [ getContextModifier getContextInferrer ] }

noContextPropertyUsage ::= propertyUsage
{implements = "com.lsfusion.lang.psi.context.PropertyUsageContext" methods = [ resolveParamClasses getParamList ]}
noContextActionUsage ::= actionUsage
{implements = "com.lsfusion.lang.psi.context.PropertyUsageContext" methods = [ resolveParamClasses getParamList ]}
noContextActionOrPropertyUsage ::= actionOrPropertyUsage
{implements = "com.lsfusion.lang.psi.context.PropertyUsageContext" methods = [ resolveParamClasses getParamList ]}
noParamsPropertyUsage ::= propertyUsage
{implements = "com.lsfusion.lang.psi.context.PropertyUsageContext" methods = [ resolveParamClasses getParamList ]}
noParamsActionUsage ::= actionUsage
{implements = "com.lsfusion.lang.psi.context.PropertyUsageContext" methods = [ resolveParamClasses getParamList ]}


dataPropertyDefinition ::= DATA (dataPropertySessionModifier)? className (LBRAC classNameList RBRAC)?
{
    pin(".*") = 1;
    implements = "com.lsfusion.lang.psi.context.UnfriendlyPE"
    methods = [ resolveUnfriendValueClass resolveValueParamClasses checkValueParamClasses getValueParamClassNames getValueClassNames getValuePropertyNames getDocumentation]
}
dataPropertySessionModifier ::= LOCAL nestedLocalModifier

nativePropertyDefinition ::= NATIVE className LBRAC classNameList RBRAC
{
    pin = 1
    implements = "com.lsfusion.lang.psi.context.UnfriendlyPE"
    methods = [ resolveUnfriendValueClass resolveValueParamClasses checkValueParamClasses getValueParamClassNames getValueClassNames getValuePropertyNames ]
}

abstractPropertyDefinition ::= ABSTRACT ((CASE | MULTI | VALUE) abstractExclusiveOverrideOption?)? 
                               (FULL)? className (LBRAC classNameList RBRAC)?
{
    pin = 1
    implements = "com.lsfusion.lang.psi.context.UnfriendlyPE"
    methods = [ resolveUnfriendValueClass resolveValueParamClasses checkValueParamClasses getValueParamClassNames getValueClassNames getValuePropertyNames getDocumentation]
}

formulaPropertyDefinition ::= FORMULA (NULL)? (builtInClassName)? formulaPropertySyntaxList
{
    pin = 1
    implements = "com.lsfusion.lang.psi.context.UnfriendlyPE"
    methods = [ resolveUnfriendValueClass resolveValueParamClasses checkValueParamClasses getValueParamClassNames getValueClassNames getValuePropertyNames getDocumentation]
}

formulaPropertySyntaxList ::= formulaPropertySyntax (COMMA formulaPropertySyntax)*

formulaPropertySyntax ::= formulaPropertySyntaxType stringLiteral 

formulaPropertySyntaxType ::= (PG | MS)?

groupingType ::= SUM | MAX | MIN | AGGR | NAGGR | EQUAL
groupingTypeOrder ::= CONCAT | LAST
groupPropertyBy ::= BY nonEmptyPropertyExpressionList { pin = 1 }
orderPropertyBy ::= ORDER (DESC)? nonEmptyPropertyExpressionList
groupPropertyBody ::= ((groupingType nonEmptyPropertyExpressionList) | (groupingTypeOrder nonEmptyPropertyExpressionList orderPropertyBy))
                        (WHERE propertyExpression)?
  
private groupByBefore ::= GROUP groupPropertyBody groupPropertyBy
//private groupByAfter ::= GROUP groupPropertyBody groupPropertyBy;
groupPropertyDefinition ::= groupByBefore //| groupByAfter
{
    implements="com.lsfusion.lang.psi.context.ExtendParamContext, com.lsfusion.lang.psi.context.UnfriendlyPE"
    methods = [ getContextModifier getContextInferrer resolveUnfriendValueClass resolveValueParamClasses checkValueParamClasses getValueParamClassNames getValueClassNames getValuePropertyNames getDocumentation]
}		

groupExprPropertyDefinition ::= GROUP groupPropertyBody
{
    pin = 1
    implements="com.lsfusion.lang.psi.context.ExtendParamContext, com.lsfusion.lang.psi.context.LSFExpression"
    methods = [ resolveInferredValueClass inferParamClasses getContextModifier getContextInferrer getValueClassNames getValuePropertyNames getDocumentation]
}		                    

filterPropertyDefinition ::= (FILTER | ORDER | VIEW) groupObjectID
{
    pin = 1
    implements = "com.lsfusion.lang.psi.context.UnfriendlyPE"
    methods = [ resolveUnfriendValueClass resolveValueParamClasses checkValueParamClasses getValueParamClassNames getValueClassNames getValuePropertyNames getDocumentation]
}

reflectionPropertyDefinition ::= REFLECTION reflectionPropertyType actionOrPropertyUsage
{
    implements = "com.lsfusion.lang.psi.context.UnfriendlyPE" 
    methods = [ resolveUnfriendValueClass resolveValueParamClasses checkValueParamClasses getValueParamClassNames getValueClassNames getValuePropertyNames ]
}

reflectionPropertyType ::= CANONICALNAME

typeIs ::= IS | AS
typePropertyDefinition ::= typeIs className
{
    pin = 1
    implements = "com.lsfusion.documentation.LSFDocumentation"
    methods = [getDocumentation]
}

private semiPropertyOption ::= IN groupUsage
                           |	persistentSetting
                           |    complexSetting
                           |    prereadSetting
                           |    hintSetting
                           |	TABLE tableUsage
                           |	asEditActionSetting
                           |	viewTypeSetting
                           |	customViewSetting
                           |	flexCharWidthSetting
                           |	charWidthSetting
                           |	imageSetting
                           |    defaultCompareSetting
                           |	changeKeySetting
                           |	changeMouseSetting
                           |	autosetSetting
                           |	confirmSetting
                           |	regexpSetting
                           |	loggableSetting
                           |	echoSymbolsSetting
                           |	indexSetting
                           |    aggrSetting
                           |	notNullSetting
                           |	eventIdSetting
                           |    stickyOption
                           |    syncTypeLiteral
                           |   ATSIGN2 simpleName
private nonSemiPropertyOption ::= onEditEventSetting

//((semiPropertyOption | nonSemiPropertyOption)* (semiPropertyOption SEMI | nonSemiPropertyOption)
// recursive-LL might be better because of pins (? naybe it would not be possible to pin 1 rule because of for example } TABLE X (A)), but needs some refactoring
//semiPropertyOption (SEMI | nonEmptyPropertyOptions) | nonSemiPropertyOption nonEmptyPropertyOptions?
nonEmptyPropertyOptions ::= ((nonSemiPropertyOption* semiPropertyOption)+ SEMI | (semiPropertyOption* nonSemiPropertyOption)+)
{
    implements = "com.lsfusion.documentation.LSFDocumentation"
    methods = [getDocumentation]
}

viewTypeSetting ::= classViewType
customViewSetting ::= propertyCustomView
persistentSetting ::= MATERIALIZED
complexSetting ::= COMPLEX | NOCOMPLEX
hintSetting ::= HINT | NOHINT
prereadSetting ::= PREREAD
charWidthSetting ::= CHARWIDTH intLiteral
flexCharWidthSetting ::= CHARWIDTH intLiteral (FLEX | NOFLEX)
imageSetting ::= IMAGE stringLiteral
defaultCompareSetting ::= DEFAULTCOMPARE stringLiteral
changeKeySetting ::= CHANGEKEY stringLiteral (SHOW | hideEditKey)?
changeMouseSetting ::= CHANGEMOUSE stringLiteral (SHOW | hideEditKey)?
autosetSetting ::= AUTOSET
confirmSetting ::= CONFIRM
regexpSetting ::= REGEXP stringLiteral (stringLiteral)?
loggableSetting ::= LOGGABLE
echoSymbolsSetting ::= ECHO
indexSetting ::= INDEXED (LIKE | MATCH)?
aggrSetting ::= AGGR
notNullSetting ::= nullOption (DELETE)? baseEvent
onEditEventSetting ::= ON formEventType topActionPropertyDefinitionBody  {pin = 2} // нельзя pin'ить 1 так как после действия ON может идти
asEditActionSetting ::= ASON formEventType noContextActionOrPropertyUsage {pin = 1}
eventIdSetting ::= EVENTID stringLiteral

stickyOption ::= STICKY | NOSTICKY

hideEditKey ::= HIDE

contextMenuEventType ::= CONTEXTMENU (<<noIDCheck>> localizedStringLiteral)? { pin = 1 } // there are a lot of rules that start from ID, so we'll ignore that cases
keyPressedEventType ::= KEYPRESS stringLiteral  { pin = 1 }
formEventType ::= CHANGE | GROUPCHANGE | CHANGEWYS | EDIT | contextMenuEventType | keyPressedEventType

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////// ACTION PROPERTIES ///////////////////////////
////////////////////////////////////////////////////////////////////////////////

abstractActionPropertyDefinition ::= ABSTRACT
                                    (   ((CASE | MULTI) abstractExclusiveOverrideOption?)
                                    |	(LIST abstractCaseAddOption?)
                                    )?
                                    (FULL)?
                                    (LBRAC classNameList RBRAC)?
{
    pin = 1
    implements = "com.lsfusion.lang.psi.context.UnfriendlyPE"
    methods = [ resolveUnfriendValueClass resolveValueParamClasses checkValueParamClasses getValueParamClassNames getValueClassNames getValuePropertyNames getDocumentation]
}

private topActionPropertyDefinitionBody ::= listActionPropertyDefinitionBody

// leaf before recursive to match newWhere before new (because first one is deeper) and importForm before import
actionPropertyDefinitionBody ::=    (   leafActionPDB
                                    |   recursiveActionPDB
                                    )                                    
{
    implements = "com.lsfusion.lang.psi.context.ActionExpression"
    methods = [ inferActionParamClasses ]
}

private recursiveActionPDB ::=  recursiveExtendContextActionPDB | recursiveKeepContextActionPDB
private recursiveExtendContextActionPDB ::=  	forActionPropertyDefinitionBody
                                            |   whileActionPropertyDefinitionBody
                                            |	dialogActionPropertyDefinitionBody // mixed, input
                                            |	inputActionPropertyDefinitionBody // mixed, input
                                            |	newActionPropertyDefinitionBody // should be after newWhere

private recursiveKeepContextActionPDB ::=  		listActionPropertyDefinitionBody
                                        |	    confirmActionPropertyDefinitionBody// mixed, input
                                        |	    newSessionActionPropertyDefinitionBody
                                        |	    requestActionPropertyDefinitionBody
                                        |	    tryActionPropertyDefinitionBody // mixed
                                        |	    ifActionPropertyDefinitionBody
                                        |	    caseActionPropertyDefinitionBody
                                        |	    multiActionPropertyDefinitionBody	
                                        |	    applyActionPropertyDefinitionBody
                                        |	    importActionPropertyDefinitionBody // mixed
                                        |       newThreadActionPropertyDefinitionBody // mixed
                                        |	    newExecutorActionPropertyDefinitionBody // mixed, recursive but allways semi

// extendContextActionPDB comes before keepContextActionPDB to check assign action before exec action
private leafActionPDB ::=  (leafExtendContextActionPDB | leafKeepContextActionPDB) SEMI | SEMI { pin(".*") = 1 } // | EMPTY and not emptyActionPropertyDefinitionBody because it would be pinned and expect seni after it everywhere
private leafExtendContextActionPDB ::=          assignActionPropertyDefinitionBody // should be before exec
                                        |	    changeClassActionPropertyDefinitionBody
                                        |	    deleteActionPropertyDefinitionBody
                                        |	    newWhereActionPropertyDefinitionBody // should be before new
                                        |       recalculateActionPropertyDefinitionBody

private leafKeepContextActionPDB ::=  	        execActionPropertyDefinitionBody // should be after assign	
                                        |	    terminalFlowActionPropertyDefinitionBody
                                      	|  	    cancelActionPropertyDefinitionBody
                                      	|	    formActionPropertyDefinitionBody
                                      	|	    printActionPropertyDefinitionBody
                                      	|	    exportActionPropertyDefinitionBody
                                      	|       exportDataActionPropertyDefinitionBody // should be after export
                                      	|	    messageActionPropertyDefinitionBody
                                      	|	    asyncUpdateActionPropertyDefinitionBody
                                      	|	    seekObjectActionPropertyDefinitionBody
                                      	|	    expandGroupObjectActionPropertyDefinitionBody
                                      	|	    collapseGroupObjectActionPropertyDefinitionBody
                                      	|	    emailActionPropertyDefinitionBody
                                      	|	    evalActionPropertyDefinitionBody
                                      	|	    drillDownActionPropertyDefinitionBody
                                      	|	    readActionPropertyDefinitionBody
                                      	|	    writeActionPropertyDefinitionBody
                                      	|	    importFormActionPropertyDefinitionBody
                                      	|	    activeFormActionPropertyDefinitionBody
                                      	|	    activateActionPropertyDefinitionBody
                                      	|	    closeFormActionPropertyDefinitionBody
                                      	|       expandCollapseActionPropertyDefinitionBody
                                      	|       internalActionPropertyDefinitionBody
                                      	|       externalActionPropertyDefinitionBody

private mappedForm ::= ((   (LIST | EDIT) customClassUsage formSingleActionObject)
                        |   (formUsage formActionObjectList?) ) {pin(".*") = 1 }

formSingleActionObject ::= formActionObjectProps
constraintFilter ::= (CONSTRAINTFILTER (EQUALS propertyExpression)?)
objectInProps ::= EQUALS propertyExpression NULL? { pin = 1 }
changeInput ::= (CHANGE (EQUALS propertyExpression)? NOCONSTRAINTFILTER? NOCHANGE?) { pin = 1 }
objectListInputProps ::= LIST propertyExpression
{
    pin = 1
    implements="com.lsfusion.lang.psi.context.ExtendParamContext"
    methods = [ getContextModifier getContextInferrer ]
}
objectInputProps ::= (INPUT | changeInput) simpleName? NULL? staticDestination? constraintFilter? objectListInputProps?
{
    pin = 1
    implements = "com.lsfusion.documentation.LSFDocumentation"
    methods = [getDocumentation]
}

private formActionObjectProps ::= objectInProps? objectInputProps? 
formActionObjectUsage ::= objectUsage formActionObjectProps {
    pin = 1
    implements="com.lsfusion.lang.psi.context.ClassParamDeclareContext,com.lsfusion.lang.psi.declarations.LSFObjectInputParamDeclaration"
    extends="com.lsfusion.lang.psi.declarations.impl.LSFObjectInputParamDeclarationImpl"
    methods = [ resolveClass ensureClass ]
}
formActionPropertyDefinitionBody ::=
	    SHOW (stringLiteral equalsSign)?
	     mappedForm
		(
		    contextFiltersClause

        |   syncTypeLiteral
		|   windowTypeLiteral

		|   manageSessionClause
		|   noCancelClause
		|   formSessionScopeClause

		|   CHECK
		|   READONLY
		)*
{
    pin = 1
    implements="com.lsfusion.lang.psi.context.ActionExpression, com.lsfusion.lang.psi.context.FormContext"
    methods = [inferActionParamClasses resolveFormDecl getDocumentation]
}

manageSessionClause ::= MANAGESESSION | NOMANAGESESSION
formSessionScopeClause ::= NEWSESSION | NESTEDSESSION
noCancelClause ::= CANCEL | NOCANCEL 

dialogActionPropertyDefinitionBody ::=
	    DIALOG
	    mappedForm
		(
		    contextFiltersClause

        |   windowTypeLiteral

		|   manageSessionClause
		|   noCancelClause
		|   formSessionScopeClause

		|   CHECK
		|   READONLY
		)*
		doInputBody
{
    pin = 1
    implements="com.lsfusion.lang.psi.context.ActionExpression, com.lsfusion.lang.psi.context.FormContext, com.lsfusion.lang.psi.context.ExtendDoParamContext"
    methods = [inferActionParamClasses resolveFormDecl getDoContextModifier getDoContextInferrer getDocumentation]
}

doInputBody ::= SEMI | (doMainBody (ELSE actionPropertyDefinitionBody)?)

doMainBody ::= DO actionPropertyDefinitionBody
{
    pin = 1
    implements="com.lsfusion.lang.psi.context.ExtendParamContext"
    methods = [ getContextModifier getContextInferrer ]
}

syncTypeLiteral ::= WAIT | NOWAIT
windowTypeLiteral ::= FLOAT | DOCKED | EMBEDDED | POPUP | (IN componentID)

staticDestination ::= TO noParamsPropertyUsage
groupObjectDestination ::= TO groupObjectUsage EQUALS propertyUsage (COMMA groupObjectUsage EQUALS propertyUsage)*

printActionPropertyDefinitionBody ::=
	    PRINT (CLIENT | SERVER)? mappedForm contextFiltersClause?
	    (
		    (
		        MESSAGE
		        syncTypeLiteral?
		        (TOP intLiteral)?
		    )
		    |
		    (
                (
                    (   XLSX sheetExpression? (PASSWORD propertyExpression)?
                    |   XLS sheetExpression? (PASSWORD propertyExpression)?
                    |   PDF
                    |   DOC
                    |   DOCX
                    |   RTF
                    |   HTML
                    )
                    staticDestination?
                )?
                (PREVIEW | NOPREVIEW)?
                syncTypeLiteral?
                (TO propertyExpression)?
		    )
	    )
{
    pin = 1
    implements="com.lsfusion.lang.psi.context.ActionExpression, com.lsfusion.lang.psi.context.FormContext"
    methods = [inferActionParamClasses resolveFormDecl getDocumentation]
}
exportActionPropertyDefinitionBody ::=
	    EXPORT mappedForm contextFiltersClause?
        (
            (
                (   CSV (stringLiteral)? hasHeaderOption? noEscapeOption? (CHARSET stringLiteral)?
                |   DBF (CHARSET stringLiteral)?
                |   XLS sheetExpression? hasHeaderOption?
                |   XLSX sheetExpression? hasHeaderOption?
                |   TABLE
                )
                (TOP intLiteral)?
                groupObjectDestination
            )
        |
            (
                (   JSON (CHARSET stringLiteral)?
                |   XML hasHeaderOption? (CHARSET stringLiteral)?
                )?
                (TOP intLiteral)?
                staticDestination?
            )
        )
        {
    pin = 2
    implements="com.lsfusion.lang.psi.context.ActionExpression, com.lsfusion.lang.psi.context.FormContext"
    methods = [inferActionParamClasses resolveFormDecl getDocumentation]
}

sheetExpression ::= SHEET propertyExpression

contextFiltersClause ::= FILTERS propertyExpression (COMMA propertyExpression)* {
    pin = 1
    implements="com.lsfusion.lang.psi.context.ExtendParamContext"
    methods = [ getContextModifier getContextInferrer ]
}

propertyExpressionWithOrder ::= propertyExpression (DESC)?

exportDataActionPropertyDefinitionBody ::=
	    EXPORT
        (   CSV (stringLiteral)? hasHeaderOption? noEscapeOption? (CHARSET stringLiteral)?
        |   DBF (CHARSET stringLiteral)?
        |   XLS sheetExpression? hasHeaderOption?
        |   XLSX sheetExpression? hasHeaderOption?
        |   JSON (CHARSET stringLiteral)?
        |   XML hasHeaderOption? (ROOT propertyExpression)? (TAG propertyExpression)? ATTR? (CHARSET stringLiteral)?
        |   TABLE
        )?
        (TOP intLiteral)?
        FROM nonEmptyAliasedPropertyExpressionList
        wherePropertyExpression?
        (ORDER propertyExpressionWithOrder (COMMA propertyExpressionWithOrder)*)?
        staticDestination?
        {
    pin = 1
    implements="com.lsfusion.lang.psi.context.ActionExpression, com.lsfusion.lang.psi.context.ExtendParamContext"
    methods = [ getContextModifier getContextInferrer inferActionParamClasses getDocumentation]
}

hasHeaderOption ::= HEADER | NOHEADER

noEscapeOption ::= ESCAPE | NOESCAPE

wherePropertyExpression ::= WHERE propertyExpression

nonEmptyAliasedPropertyExpressionList ::= aliasedPropertyExpression (COMMA aliasedPropertyExpression)* 
        
aliasedPropertyExpression ::= ((ID | stringLiteral) EQUALS)? propertyExpression

formActionObjectList ::= OBJECTS formActionObjectUsage (COMMA formActionObjectUsage)* {pin(".*") = 1}

bracketedClassNameList ::= LBRAC classNameList RBRAC
jsStringUsage ::= stringLiteral
customActionPropertyDefinitionBody ::= INTERNAL ((CLIENT jsStringUsage bracketedClassNameList?) | (javaClassStringUsage bracketedClassNameList?)  | codeLiteral) (NULL)?
{
    pin = 1
    implements="com.lsfusion.lang.psi.context.UnfriendlyPE"
    methods = [resolveUnfriendValueClass resolveValueParamClasses checkValueParamClasses getValueParamClassNames getValueClassNames getValuePropertyNames getDocumentation]
}

internalActionPropertyDefinitionBody ::= INTERNAL (DB | (CLIENT syncTypeLiteral?)) propertyExpression (PARAMS nonEmptyPropertyExpressionList)? (TO nonEmptyNoParamsPropertyUsageList)?
{
    pin = 1
    implements="com.lsfusion.lang.psi.context.ActionExpression"
    methods = [inferActionParamClasses getDocumentation]
}

externalActionPropertyDefinitionBody ::= EXTERNAL externalType (PARAMS nonEmptyPropertyExpressionList)? (TO nonEmptyNoParamsPropertyUsageList)?
{
    pin = 1
    implements="com.lsfusion.lang.psi.context.ActionExpression"
    methods = [inferActionParamClasses getDocumentation]
//    implements="com.lsfusion.lang.psi.context.UnfriendlyPE"
//    methods = [resolveUnfriendValueClass resolveValueParamClasses checkValueParamClasses getValueParamClassNames getValueClassNames getValuePropertyNames]
}

private externalType ::=  SQL propertyExpression EXEC propertyExpression
              |   TCP (CLIENT)? propertyExpression
              |   UDP (CLIENT)? propertyExpression
              |   HTTP (CLIENT)? (DELETE| GET | POST | PUT)? propertyExpression (BODYURL propertyExpression)?
                    (BODYPARAMNAMES stringLiteral (COMMA stringLiteral)*)?
                    (BODYPARAMHEADERS headersPropertyUsage (COMMA headersPropertyUsage)*)?
                    (HEADERS headersPropertyUsage)? (COOKIES headersPropertyUsage)? (HEADERSTO headersPropertyUsage)? (COOKIESTO headersPropertyUsage)?
              |   DBF propertyExpression APPEND (CHARSET stringLiteral)?
              |   LSF propertyExpression (EXEC | (EVAL (ACTION)?)) propertyExpression
              |   JAVA propertyExpression
              {pin(".*") = 1}

headersPropertyUsage ::= propertyUsage
{
    implements = "com.lsfusion.lang.psi.context.PropertyUsageContext"
    methods = [ resolveParamClasses getParamList]
}

javaClassStringUsage ::= stringLiteral
{
    mixin="com.lsfusion.lang.psi.references.impl.LSFJavaClassStringReferenceImpl"
    implements="com.lsfusion.lang.psi.references.LSFJavaClassStringReference"
}

private newWhereToClause ::= TO mappedPropertyExprParam { pin = 1 }
private newWhereClause ::= WHERE propertyExpression newWhereToClause? { pin = 1 }

newWhereActionPropertyDefinitionBody ::= NEW customClassUsage newWhereClause
{
    pin = 3
    implements="com.lsfusion.lang.psi.context.ExtendParamContext, com.lsfusion.lang.psi.context.ActionExpression"
    methods = [ getContextModifier getContextInferrer inferActionParamClasses getDocumentation ]
}

emailActionPropertyDefinitionBody ::=
		EMAIL
		(FROM propertyExpression)?
		(SUBJECT propertyExpression)?
		(emailRecipientTypeLiteral propertyExpression)+
		(BODY propertyExpression)?
		(ATTACH ((propertyExpression (NAME propertyExpression)?) | (LIST emailPropertyUsage (NAME emailPropertyUsage)?)))*
        syncTypeLiteral?
{
    pin = 1
    implements="com.lsfusion.lang.psi.context.ActionExpression"
    methods = [inferActionParamClasses getDocumentation]
}

emailPropertyUsage ::= propertyUsage
{
    implements = "com.lsfusion.lang.psi.context.PropertyUsageContext"
    methods = [ resolveParamClasses getParamList]
}

confirmActionPropertyDefinitionBody ::= ASK propertyExpression ((paramDeclare EQUALS)? YESNO)? doInputBody
{
    pin = 1
    implements="com.lsfusion.lang.psi.context.ActionExpression,com.lsfusion.lang.psi.context.ClassParamDeclareContext, com.lsfusion.lang.psi.context.ExtendDoParamContext"
    methods = [inferActionParamClasses resolveClass ensureClass getDoContextModifier getDoContextInferrer getDocumentation]
}

messageActionPropertyDefinitionBody ::= MESSAGE propertyExpression (syncTypeLiteral | LOG)*
{
    pin = 1
    implements="com.lsfusion.lang.psi.context.ActionExpression"
    methods = [inferActionParamClasses getDocumentation]
}

asyncUpdateActionPropertyDefinitionBody ::= ASYNCUPDATE propertyExpression
{
    pin = 1
    implements="com.lsfusion.lang.psi.context.ActionExpression"
    methods = [inferActionParamClasses]
}

objectExpr ::= objectUsage EQUALS propertyExpression

seekObjectActionPropertyDefinitionBody ::= SEEK (FIRST | LAST | NULL)? 
                                            (   (objectID EQUALS propertyExpression) 
                                            |   (groupObjectID (OBJECTS objectExpr (COMMA objectExpr)*)?)
                                            )
{                        
    pin = 1
    implements="com.lsfusion.lang.psi.context.ActionExpression, com.lsfusion.lang.psi.context.FormContext"
    methods = [inferActionParamClasses resolveFormDecl getDocumentation]
}

expandGroupObjectActionPropertyDefinitionBody ::= EXPAND (DOWN | UP | ALL (TOP)?)?
                                            groupObjectID (OBJECTS objectExpr (COMMA objectExpr)*)?
{
    pin = 3
    implements="com.lsfusion.lang.psi.context.ActionExpression, com.lsfusion.lang.psi.context.FormContext"
    methods = [inferActionParamClasses resolveFormDecl]
}

collapseGroupObjectActionPropertyDefinitionBody ::= COLLAPSE (DOWN | ALL (TOP)?)?
                                            groupObjectID (OBJECTS objectExpr (COMMA objectExpr)*)?
{
    pin = 3
    implements="com.lsfusion.lang.psi.context.ActionExpression, com.lsfusion.lang.psi.context.FormContext"
    methods = [inferActionParamClasses resolveFormDecl]
}

// the same trick as with formPropertyDrawMappedDecl
parameterOrExpression ::=
        (<<checkParameterOrExpression>> &((exprParameterUsage <<matchedSingleParameter>>)?) propertyExpression <<matchedParameterOrExpression>>) |
        exprParameterUsage
nonEmptyParameterOrExpressionList ::= parameterOrExpression (COMMA parameterOrExpression)* { pin(".*") = 1}
parameterOrExpressionList ::= (nonEmptyParameterOrExpressionList)?
        
changeClassWhere ::= WHERE propertyExpression

changeClassActionPropertyDefinitionBody ::= CHANGECLASS parameterOrExpression TO customClassUsage changeClassWhere?
{
    pin = 1
    implements="com.lsfusion.lang.psi.context.ExtendParamContext, com.lsfusion.lang.psi.context.ActionExpression"
    methods = [ getContextModifier getContextInferrer inferActionParamClasses getDocumentation ]
}

deleteActionPropertyDefinitionBody ::= DELETE parameterOrExpression changeClassWhere?
{
    pin = 1
    implements="com.lsfusion.lang.psi.context.ExtendParamContext, com.lsfusion.lang.psi.context.ActionExpression"
    methods = [ getContextModifier getContextInferrer inferActionParamClasses getDocumentation ]
}

evalActionPropertyDefinitionBody ::= EVAL (ACTION)? propertyExpression (PARAMS propertyExpressionList)?
{
    pin = 1
    implements="com.lsfusion.lang.psi.context.ActionExpression"
    methods = [inferActionParamClasses getDocumentation]
}

readActionPropertyDefinitionBody ::= READ (CLIENT DIALOG?)? propertyExpression (TO noParamsPropertyUsage)?
{
    pin = 1
    implements="com.lsfusion.lang.psi.context.ActionExpression"
    methods = [inferActionParamClasses getDocumentation]
}

writeActionPropertyDefinitionBody ::= WRITE (CLIENT DIALOG?)? propertyExpression TO propertyExpression APPEND?
{
    pin = 1
    implements="com.lsfusion.lang.psi.context.ActionExpression"
    methods = [inferActionParamClasses getDocumentation]
}

importActionPropertyDefinitionBody ::= IMPORT importActionSourceType? FROM propertyExpression
    ((FIELDS (LBRAC classParamDeclareList RBRAC)? nonEmptyImportFieldDefinitions doInputBody) | (TO (LBRAC classNameList RBRAC)? nonEmptyImportPropertyUsageListWithIds (WHERE propertyUsage)?))
{
    pin(".*") = 1
    implements="com.lsfusion.lang.psi.context.ActionExpression, com.lsfusion.lang.psi.context.ExtendDoParamContext"
    methods = [inferActionParamClasses getDoContextModifier getDoContextInferrer getDocumentation]
}

nonEmptyImportFieldDefinitions ::= importFieldDefinition (COMMA importFieldDefinition)*

importFieldAlias ::= simpleName
importFieldName ::= simpleName | stringLiteral

importFieldDefinition ::= builtInClassName (importFieldAlias EQUALS)? importFieldName NULL? {
    implements="com.lsfusion.lang.psi.context.ClassParamDeclareContext,com.lsfusion.lang.psi.declarations.LSFImportFieldParamDeclaration"
    extends="com.lsfusion.lang.psi.declarations.impl.LSFImportFieldParamDeclartionImpl"
    methods = [ resolveClass ensureClass ]
}

importPropertyUsage ::= propertyUsage
{
    implements = "com.lsfusion.lang.psi.context.PropertyUsageContext"
    methods = [ resolveParamClasses getParamList]
}

importFormActionPropertyDefinitionBody ::= IMPORT formUsage (
    (importFormPlainActionSourceType FROM groupObjectUsage EQUALS propertyExpression (COMMA groupObjectUsage EQUALS propertyExpression)*)
    |
    (importFormHierarchicalActionSourceType? (FROM (propertyExpression))?))
{
    pin = 2
    implements="com.lsfusion.lang.psi.context.ActionExpression, com.lsfusion.lang.psi.context.FormContext"
    methods = [inferActionParamClasses resolveFormDecl getDocumentation]
}

importActionSourceType ::=  CSV (stringLiteral)? (HEADER|NOHEADER)? (ESCAPE|NOESCAPE)? (WHERE propertyExpression)? (CHARSET stringLiteral)?
                        |   DBF (MEMO propertyExpression)? (WHERE propertyExpression)? (CHARSET stringLiteral)?
                        |   XLS (HEADER|NOHEADER)? (SHEET (propertyExpression | ALL))? (WHERE propertyExpression)?
                        |   JSON (ROOT propertyExpression)? (CHARSET stringLiteral)?
                        |   XML (ROOT propertyExpression)? (ATTR)?
                        |   TABLE (WHERE propertyExpression)?

importFormPlainActionSourceType ::=  CSV (stringLiteral)? (HEADER|NOHEADER)? (ESCAPE|NOESCAPE)? (CHARSET stringLiteral)?
                                 |   DBF (CHARSET stringLiteral)?
                                 |   XLS (HEADER|NOHEADER)? (SHEET (propertyExpression | ALL))?
                                 |   TABLE

importFormHierarchicalActionSourceType ::=  JSON (ROOT propertyExpression)? (CHARSET stringLiteral)?
                                        |   XML (ROOT propertyExpression)? (CHARSET stringLiteral)?

newThreadActionPropertyDefinitionBody ::= NEWTHREAD actionPropertyDefinitionBody
                                        (   (   CONNECTION propertyExpression
                                            |   (SCHEDULE (PERIOD propertyExpression)? (DELAY propertyExpression)?)
                                            )
                                            SEMI
                                        )?
{
    pin = 1
    implements="com.lsfusion.lang.psi.context.ActionExpression"
    methods = [inferActionParamClasses getDocumentation]
}

newExecutorActionPropertyDefinitionBody ::= NEWEXECUTOR actionPropertyDefinitionBody THREADS propertyExpression SEMI
{
    pin = 1
    implements="com.lsfusion.lang.psi.context.ActionExpression"
    methods = [inferActionParamClasses getDocumentation]
}

newSessionOperator ::= NEWSESSION
{
    implements = "com.lsfusion.documentation.LSFDocumentation"
    methods = [getDocumentation]
}
nestedSessionOperator ::= NESTEDSESSION
{
    implements = "com.lsfusion.documentation.LSFDocumentation"
    methods = [getDocumentation]
}
newSessionActionPropertyDefinitionBody ::= (    newSessionOperator (NEWSQL)? nestedPropertiesSelector?
                                           |    nestedSessionOperator
                                           )
                                           (SINGLE)?
                                           actionPropertyDefinitionBody
{
    pin(".*") = 1
    implements="com.lsfusion.lang.psi.context.ActionExpression"
    methods = [inferActionParamClasses]
}

nonEmptyImportPropertyUsageListWithIds ::= importPropertyUsageWithId (COMMA importPropertyUsageWithId)*

importPropertyUsageWithId ::= importPropertyUsage (EQUALS (ID | stringLiteral))? 

drillDownActionPropertyDefinitionBody ::= DRILLDOWN propertyExpression
{
    pin = 1
    implements="com.lsfusion.lang.psi.context.ActionExpression"
    methods = [inferActionParamClasses]
}

requestActionPropertyDefinitionBody ::= REQUEST actionPropertyDefinitionBody DO actionPropertyDefinitionBody (ELSE actionPropertyDefinitionBody)?
{
    pin = 1
    implements="com.lsfusion.lang.psi.context.ActionExpression"
    methods = [inferActionParamClasses getDocumentation]
}

// the same trick as with formPropertyDrawMappedDecl
classOrExpression ::=
        (<<checkClassOrExpression>> &((customClassUsage <<matchedClass>>)?) propertyExpression <<matchedClassOrExpression>>) |
        customClassUsage
private listInputProp ::= LIST propertyExpression {pin = 1}
private whereInputProp ::= WHERE propertyExpression {pin = 1}
listWhereInputProps ::= listInputProp? whereInputProp?
{
    implements="com.lsfusion.lang.psi.context.ExtendParamContext"
    methods = [ getContextModifier getContextInferrer ]
}
contextActions ::= ACTIONS contextAction (COMMA contextAction)*
{
    implements="com.lsfusion.lang.psi.context.ExtendParamContext"
    methods = [ getContextModifier getContextInferrer ]
}
contextAction ::= stringLiteral (KEYPRESS stringLiteral)? (TOOLBAR ((ALL | SELECTED | FOCUSED) HOVER?)*)? listActionPropertyDefinitionBody
{
    implements="com.lsfusion.lang.psi.context.ExtendParamContext"
    methods = [ getContextModifier getContextInferrer ]
}
changeInputPropertyCustomView ::= CUSTOM stringLiteral?
inputActionPropertyDefinitionBody ::= INPUT (((paramDeclare EQUALS)? builtInClassName) | (paramDeclare? EQUALS classOrExpression)) (CHANGE (EQUALS propertyExpression)? NOCONSTRAINTFILTER? NOCHANGE?)? changeInputPropertyCustomView? listWhereInputProps contextActions? formSessionScopeClause? staticDestination? doInputBody
{
    pin = 1
    implements="com.lsfusion.lang.psi.context.ActionExpression, com.lsfusion.lang.psi.context.ClassParamDeclareContext, com.lsfusion.lang.psi.context.ExtendDoParamContext"
    methods = [inferActionParamClasses resolveClass ensureClass getDoContextModifier getDoContextInferrer getDocumentation]
}

activeFormActionPropertyDefinitionBody ::= ACTIVE FORM formUsage
{
    pin = 1
    implements="com.lsfusion.lang.psi.context.ActionExpression"
    methods = [inferActionParamClasses getDocumentation]
}

emptyActionPropertyDefinitionBody ::= 

activateActionPropertyDefinitionBody ::= ACTIVATE (  FORM formUsage 
                                                   | TAB componentID
                                                   | PROPERTY formPropertyDrawID
                                                   )
{
    pin = 1
    implements="com.lsfusion.lang.psi.context.ActionExpression"
    methods = [inferActionParamClasses getDocumentation]
}

//todo: add getDocumentation
closeFormActionPropertyDefinitionBody ::= CLOSE FORM stringLiteral
{
    pin = 1
    implements="com.lsfusion.lang.psi.context.ActionExpression"
    methods = [inferActionParamClasses]
}


expandCollapseActionPropertyDefinitionBody ::= (COLLAPSE | EXPAND) CONTAINER componentID
{
    pin = 3
    implements="com.lsfusion.lang.psi.context.ActionExpression"
    methods = [inferActionParamClasses]
}                                         

listActionPropertyDefinitionBody ::=    LBRACE
			                            listActionStatement*
		                                RBRACE
{
    pin = 1
    mixin="com.lsfusion.lang.psi.LSFListActionImpl"
    implements="com.lsfusion.lang.psi.LSFListAction, com.lsfusion.lang.psi.context.ActionExpression"
    methods = [inferActionParamClasses resolveAllParams getDocumentation]
}

private nestedPropertiesSelector ::= NESTED (LOCAL | (LBRAC nonEmptyNoContextPropertyUsageList RBRAC))

private listActionStatement ::= (   actionPropertyDefinitionBody //  !} => ;
                                |   localDataPropertyDefinition SEMI
                                )
{
    pin(".*") = 1
    recoverWhile = "list_action_statement_recover"
}

// some statements are not pinned after the first token, so we need these fake rules to pin incomplete statements (to support recovery assertion) 
// Important ! after recover the rule should mandatory be pinned (matched)
private list_action_statement_recover ::= !(ACTIVATE | ACTIVE | NEW | NEWEDIT | APPLY | CANCEL | CHANGE | ASK | ASYNCUPDATE | BREAK | CASE | CHANGECLASS | CONFIRM | INTERNAL | DELETE
                                            | DRILLDOWN | EDIT | EMAIL | EVAL | EXEC | FOR | SHOW | CLOSE | DIALOG | PRINT | EXPORT | TRY | IF | IMPORT | LOCAL | MESSAGE | MULTI
                                            | READ | REQUEST | INPUT | RETURN | SEEK | WHILE| WRITE | RECALCULATE
                                            | NEWEXECUTOR | NEWSESSION | NEWTHREAD | NESTEDSESSION
                                            | COLLAPSE | EXPAND
                                            | EXTERNAL
                                            | ID // pinned with execActionPropertyDefinitionBody
                                            | SEMI
                                            | LBRACE
                                            | RBRACE // would not be pinned (matched) but we will consider it the end of list statement
                                           )

localDataPropertyDefinition ::= LOCAL nestedLocalModifier nonEmptyLocalPropertyDeclarationNameList EQUALS className LBRAC classNameList RBRAC
{
    pin = 1
    implements = "com.lsfusion.documentation.LSFDocumentation"
    methods = [getDocumentation]
}

nestedLocalModifier ::= (NESTED manageSessionClause?)?
{
    implements = "com.lsfusion.documentation.LSFDocumentation"
}

nonEmptyLocalPropertyDeclarationNameList ::= localPropertyDeclarationName (COMMA localPropertyDeclarationName)*

localPropertyDeclarationName ::= simpleName
{
    mixin="com.lsfusion.lang.psi.declarations.impl.LSFLocalPropDeclarationImpl"
    implements="com.lsfusion.lang.psi.declarations.LSFLocalPropDeclaration"
}

//Разбиваем правило, чтобы была возможность запинить по EXEC
execActionPropertyDefinitionBody ::= execActionPropertyDefinitionBody1 | execActionPropertyDefinitionBody2
{
    implements = "com.lsfusion.lang.psi.context.PropertyUsageContext, com.lsfusion.lang.psi.context.ActionExpression"
    methods = [ resolveParamClasses inferActionParamClasses getParamList getDocumentation ]
}
private execActionPropertyDefinitionBody1 ::= EXEC actionUsage LBRAC propertyExpressionList RBRAC {pin = 1}
//EXEC - последнее правило, которое может начинаться с ID, поэтому спокойно пиним
private execActionPropertyDefinitionBody2 ::= actionUsage LBRAC propertyExpressionList RBRAC {pin = 1}

//Разбиваем правило, чтобы была возможность запинить по ASSIGN
assignActionPropertyDefinitionBody ::= assignActionPropertyDefinitionBody1 | assignActionPropertyDefinitionBody2
{
    implements="com.lsfusion.lang.psi.context.ExtendParamContext, com.lsfusion.lang.psi.context.ActionExpression"
    methods = [ getContextModifier getContextInferrer inferActionParamClasses getDocumentation ]
}

changePropertyBody ::= propertyUsage LBRAC parameterOrExpressionList RBRAC
{
    implements = "com.lsfusion.lang.psi.context.PropertyUsageContext"
    methods = [ resolveParamClasses getParamList ]
}

private assignActionPropertyDefinitionBody1 ::= CHANGE changePropertyBody ARROW propertyExpression (WHERE propertyExpression)? {pin = 1}
private assignActionPropertyDefinitionBody2 ::= changePropertyBody ARROW propertyExpression (WHERE propertyExpression)? {pin = 2}

tryActionPropertyDefinitionBody ::= TRY actionPropertyDefinitionBody (CATCH actionPropertyDefinitionBody)? (FINALLY actionPropertyDefinitionBody)?
{
    pin = 1
    implements="com.lsfusion.lang.psi.context.ActionExpression" methods = [inferActionParamClasses getDocumentation]
}

ifActionPropertyDefinitionBody ::= IF propertyExpression THEN actionPropertyDefinitionBody (ELSE actionPropertyDefinitionBody)?
{
    pin = 1
    implements="com.lsfusion.lang.psi.context.ActionExpression" methods = [inferActionParamClasses getDocumentation]
}

caseActionPropertyDefinitionBody ::= CASE (exclusiveOverrideOption)? (actionCaseBranchBody)+ (ELSE actionPropertyDefinitionBody)?
{
    pin = 1
    implements="com.lsfusion.lang.psi.context.ActionExpression"
    methods = [inferActionParamClasses getDocumentation]
}

actionCaseBranchBody ::= WHEN propertyExpression (THEN actionPropertyDefinitionBody) {pin(".*") = 1}

multiActionPropertyDefinitionBody ::= MULTI (exclusiveOverrideOption)? nonEmptyActionPDBList
{
    pin = 1
    implements="com.lsfusion.lang.psi.context.ActionExpression"
    methods = [inferActionParamClasses getDocumentation]
}

applyActionPropertyDefinitionBody ::= APPLY nestedPropertiesSelector? SINGLE? SERIALIZABLE? actionPropertyDefinitionBody
{
    pin = 1
    implements="com.lsfusion.lang.psi.context.ActionExpression"
    methods = [inferActionParamClasses getDocumentation]
}

cancelActionPropertyDefinitionBody ::= CANCEL nestedPropertiesSelector?
{
    pin = 1
    implements="com.lsfusion.lang.psi.context.ActionExpression"
    methods = [inferActionParamClasses getDocumentation]
}

forAddObjClause ::= NEW (paramDeclare EQUALS)? customClassUsage AUTOSET?
{
    pin = 1
    implements="com.lsfusion.lang.psi.context.ClassParamDeclareContext"
    methods = [ resolveClass ensureClass ]
}

forActionPropertyDefinitionBody ::= forActionPropertyMainBody
		                            (ELSE actionPropertyDefinitionBody)?
{
    implements="com.lsfusion.lang.psi.context.ActionExpression"
    methods = [ inferActionParamClasses ]
}

newActionPropertyDefinitionBody ::= forAddObjClause
                              actionPropertyDefinitionBody
{
    pin = 1
    implements="com.lsfusion.lang.psi.context.ExtendParamContext, com.lsfusion.lang.psi.context.ActionExpression"
    methods = [ getContextModifier getContextInferrer inferActionParamClasses getDocumentation ]
}

recalculateActionPropertyDefinitionBody ::= RECALCULATE propertyExpression (WHERE propertyExpression)?
{
    pin = 1
    implements="com.lsfusion.lang.psi.context.ExtendParamContext, com.lsfusion.lang.psi.context.ActionExpression"
    methods = [ getContextModifier getContextInferrer inferActionParamClasses ]
}

forActionPropertyMainBody ::= FOR propertyExpression (ORDER (DESC)? nonEmptyPropertyExpressionList)?
                              inlineOption
                              (forAddObjClause)?
                              DO actionPropertyDefinitionBody
{
    pin = 1
    implements="com.lsfusion.lang.psi.context.ExtendParamContext"
    methods = [ getContextModifier getContextInferrer getDocumentation ]
}
                                                       
whileActionPropertyDefinitionBody ::= WHILE (propertyExpression (ORDER (DESC)? nonEmptyPropertyExpressionList)? )?
		                              inlineOption
		                              (forAddObjClause)?
		                              DO actionPropertyDefinitionBody
{
    pin = 1
    implements="com.lsfusion.lang.psi.context.ExtendParamContext, com.lsfusion.lang.psi.context.ActionExpression"
    methods = [ getContextModifier getContextInferrer inferActionParamClasses getDocumentation ]
}

breakActionOperator ::= BREAK
{
    implements = "com.lsfusion.documentation.LSFDocumentation"
    methods = [getDocumentation]
}
returnActionOperator ::= RETURN
{
    implements = "com.lsfusion.documentation.LSFDocumentation"
    methods = [getDocumentation]
}
terminalFlowActionPropertyDefinitionBody ::= breakActionOperator | returnActionOperator
{
    implements="com.lsfusion.lang.psi.context.ActionExpression" methods = [inferActionParamClasses]
}

////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////// FORM STATEMENT /////////////////////////////
////////////////////////////////////////////////////////////////////////////////

formStatement ::=	(	formDecl
            		|	extendingFormDeclaration
		            )
                    (	formGroupObjectsList
                    |	formTreeGroupObjectList
                    |	formFiltersList
                    |	formPropertiesList
                    |	formHintsList
                    |	formEventsList
                    |	formFilterGroupDeclaration
                    |	formExtendFilterGroupDeclaration
                    |   userFiltersDeclaration
                    |	formOrderByList
                    |	formPivotOptionsDeclaration
                    |	listFormDeclaration
                    |	editFormDeclaration
                    |   reportFilesDeclaration
                    |   reportSetting
                    |   formExtIDSetting
                    )*
                    emptyStatement
{
    pin=1
    elementTypeFactory = "com.lsfusion.lang.psi.stubs.types.LSFStubElementTypeFactory.create"
    stubClass = "com.lsfusion.lang.psi.stubs.extend.ExtendFormStubElement"
    implements="com.lsfusion.lang.psi.extend.LSFFormExtend, com.lsfusion.lang.psi.context.FormContext"
    mixin="com.lsfusion.lang.psi.extend.impl.LSFFormExtendImpl"
    methods = [resolveFormDecl]
}

listFormDeclaration ::= LIST customClassUsage OBJECT objectUsage
{
    pin = 1
    implements = "com.lsfusion.documentation.LSFDocumentation"
    methods = [getDocumentation]
}
editFormDeclaration ::= EDIT customClassUsage OBJECT objectUsage
{
    pin = 1
    implements = "com.lsfusion.documentation.LSFDocumentation"
    methods = [getDocumentation]
}

reportFilesDeclaration ::= REPORTFILES groupObjectReportPath (COMMA groupObjectReportPath)* {pin = 1}

reportSetting ::= REPORT formCalcPropertyObject
{
    pin = 1
    implements = "com.lsfusion.documentation.LSFDocumentation"
    methods = [getDocumentation]
}

formExtIDSetting ::= FORMEXTID stringLiteral
{
    pin = 1
    implements = "com.lsfusion.documentation.LSFDocumentation"
    methods = [getDocumentation]
}

groupObjectReportPath ::= (TOP | groupObjectUsage) formCalcPropertyObject

formDecl ::= FORM simpleNameWithCaption
		            (   IMAGE stringLiteral
		            |   autorefreshLiteral
		            |   LOCALASYNC
		            )*
{
    pin = 2
    mixin ="com.lsfusion.lang.psi.declarations.impl.LSFFormDeclarationImpl"
    implements="com.lsfusion.lang.psi.declarations.LSFFormDeclaration"
    methods = [getDocumentation]
    stubClass = "com.lsfusion.lang.psi.stubs.FormStubElement"
    elementTypeFactory = "com.lsfusion.lang.psi.stubs.types.LSFStubElementTypeFactory.create"
}

autorefreshLiteral ::= AUTOREFRESH intLiteral

extendingFormDeclaration ::= EXTEND FORM formUsageWrapper
{
    pin = 2
    implements = "com.lsfusion.documentation.LSFDocumentation"
    methods = [getDocumentation]
}

formUsageWrapper ::= formUsage // for usages search filter

formGroupObjectsList ::= OBJECTS formGroupObjectDeclaration (COMMA formGroupObjectDeclaration)*
{
    pin = 1
    implements = "com.lsfusion.documentation.LSFDocumentation"
    methods = [getDocumentation]
}

formTreeGroupObjectList ::= TREE (treeGroupDeclaration)? formTreeGroupObjectDeclaration (COMMA formTreeGroupObjectDeclaration)* formTreeGroupObjectOptions
{
    pin = 1
    implements = "com.lsfusion.documentation.LSFDocumentation"
    methods = [getDocumentation]
}

treeGroupDeclaration ::= simpleName
{
    implements="com.lsfusion.lang.psi.declarations.LSFTreeGroupDecl"
    mixin="com.lsfusion.lang.psi.declarations.impl.LSFTreeGroupDeclImpl"
}

formGroupObjectDeclaration ::= formGroupObject formGroupObjectOptions
formGroupObjectOptions ::= (    formGroupObjectViewType 
                           |    formSubReport 
                           |    formGroupObjectInitViewType
                           |    formGroupObjectPageSize
                           |    formGroupObjectUpdate
                           |    formGroupObjectRelativePosition
                           |    formGroupObjectBackground
                           |    formGroupObjectForeground
                           |    formInGroup
                           |    formExtID
                           )*
{
    implements = "com.lsfusion.documentation.LSFDocumentation"
    methods = [getDocumentation]
}

formTreeGroupObjectOptions ::= (   formGroupObjectRelativePosition
                               )*
                           
formTreeGroupObjectDeclaration ::= formGroupObject (treeGroupParentDeclaration)?
{implements = "com.lsfusion.lang.psi.context.PropertyUsageContext" methods = [ resolveParamClasses getParamList ]}

treeGroupParentDeclaration ::= (PARENT formExprDeclaration) | (LBRAC PARENT formExprDeclaration (COMMA formExprDeclaration)* RBRAC) { pin = 1 }

formGroupObject ::= formSingleGroupObjectDeclaration | formMultiGroupObjectDeclaration
{mixin="com.lsfusion.lang.psi.declarations.impl.LSFGroupObjectDeclarationImpl" implements="com.lsfusion.lang.psi.declarations.LSFGroupObjectDeclaration"}

formGroupObjectViewType ::= classViewType | listViewType
formGroupObjectInitViewType ::= INIT | FIXED

formSubReport ::= SUBREPORT formCalcPropertyObject?

classViewType ::= PANEL | GRID | TOOLBAR

renderPropertyCustomView ::= stringLiteral
changePropertyCustomView ::= CHANGE stringLiteral?
propertyCustomView ::= CUSTOM ((renderPropertyCustomView changePropertyCustomView) | renderPropertyCustomView | changePropertyCustomView)

listViewType ::= (PIVOT <<pivotCheck>> (DEFAULT | NODEFAULT)? pivotOptions) | (MAP mapOptions?) | (CUSTOM stringLiteral (OPTIONS propertyExpression)?) | CALENDAR

pivotOptions ::= (stringLiteral | (SUM | MAX | MIN) | (SETTINGS | NOSETTINGS) | (CONFIG stringLiteral))*

mapOptions ::= stringLiteral

formGroupObjectPageSize ::= PAGESIZE intLiteral

formGroupObjectUpdate ::= FIRST | LAST | PREV | NULL

formGroupObjectRelativePosition ::= FIRST | (AFTER | BEFORE) groupObjectUsage {pin = 1}

formGroupObjectBackground ::= BACKGROUND formCalcPropertyObject
formGroupObjectForeground ::= FOREGROUND formCalcPropertyObject

formSingleGroupObjectDeclaration ::= formObjectDeclaration

formMultiGroupObjectDeclaration ::= (simpleName EQUALS)?
		                            LBRAC
			                        formObjectDeclaration (COMMA formObjectDeclaration)*
		                            RBRAC

formObjectDeclaration ::= (simpleName? localizedStringLiteral? EQUALS)?
		                  className
		                  (ON CHANGE formActionPropertyObject)?
{
    mixin="com.lsfusion.lang.psi.declarations.impl.LSFObjectDeclarationImpl"
    implements="com.lsfusion.lang.psi.declarations.LSFObjectDeclaration"
}

formPropertyDrawNameDecl ::= (simpleNameOrWithCaption EQUALS)? formPropertyName formPropertyOptionsList
{
    mixin="com.lsfusion.lang.psi.declarations.impl.LSFPropertyDrawNameDeclarationImpl"
    implements="com.lsfusion.lang.psi.declarations.LSFPropertyDrawNameDeclaration"
}

formPropertiesNamesDeclList ::=	formPropertyDrawNameDecl (COMMA formPropertyDrawNameDecl)*

formPropertiesList ::=  PROPERTIES (formMappedNamePropertiesList | formPropertyOptionsList formMappedPropertiesList)
{
    pin = 1
    implements = "com.lsfusion.documentation.LSFDocumentation"
    methods = [getDocumentation]
}

formMappedNamePropertiesList ::= LBRAC objectUsageList RBRAC formPropertyOptionsList formPropertiesNamesDeclList
{
    pin = 1
    implements = "com.lsfusion.lang.psi.context.PropertyUsageContext"
    methods = [ resolveParamClasses getParamList]
}

formPropertyOptionsList ::= (    CHANGEABLE | READONLY | SELECTOR
                            |    formOptionSession
                            |    HINTNOUPDATE
                            |    HINTTABLE
                            |    OPTIMISTICASYNC
                            |    formOptionForce
                            |    formOptionCustomView
                            |    formOptionToDraw
                            |    formOptionEventId
                            |    formOptionColumns
                            |    formOptionsWithCalcPropertyObject
                            |    formOptionsOnEvents
                            |    formOptionQuickFilter
                            |    formOptionInsertType
                            |    ATTR
                            |    formInGroup
                            |    formExtID | NOEXTID
                            |    EXTNULL
                            |    ORDER (DESC)?
                            |    FILTER
                            |    COLUMN
                            |    ROW
                            |    MEASURE
                            |    stickyOption
                            |    syncTypeLiteral
                            )*

formOptionSession ::= NEWSESSION | NESTEDSESSION;
formOptionColumns ::= COLUMNS (stringLiteral)? LBRAC nonEmptyGroupObjectUsageList RBRAC {pin = 1}
formOptionForce ::= classViewType
formOptionCustomView ::= propertyCustomView
formOptionToDraw ::= DRAW groupObjectUsage {pin = 1}
formOptionEventId ::= EVENTID stringLiteral {pin = 1}
formOptionsWithCalcPropertyObject ::= (SHOWIF | READONLYIF | BACKGROUND | FOREGROUND | IMAGE | HEADER | FOOTER) formCalcPropertyObject {pin = 1}
formOptionQuickFilter ::= QUICKFILTER formPropertyDrawUsage {pin = 1}
formOptionInsertType ::= FIRST | (BEFORE | AFTER) formPropertyDrawUsage {pin = 1}
formOptionsOnEvents ::= ON formEventType formActionPropertyObject
{
    pin = 1
    implements = "com.lsfusion.documentation.LSFDocumentation"
    methods = [getDocumentation]
}

formInGroup ::= IN groupUsage

formExtID ::= EXTID stringLiteral

designCalcPropertyObject ::= formCalcPropertyObject
formCalcPropertyObject ::= formExprDeclaration
formActionPropertyObject ::= formActionObject | formActionDeclaration

formPropertyDrawMappedDecl ::= (formPropertyDrawObject  
                               | (simpleNameOrWithCaption? EQUALS (
                                                        // pretty tricky solution, we do lookahead to match formPropertyDrawObject, then we save last token and compare it to last token in formExprDeclaration, if the same - move to formPropertyDrawObject, otherwise map formExprDeclaration, the same approach is used in CHANGECLASS / DELETE  
                                                        (<<checkFormExpr>> &((formPropertyDrawObject <<matchedFormDrawObject>>)?) formExprDeclaration <<matchedFormExpr>>) | 
                                                        formPropertyDrawObject | 
                                                        formActionDeclaration)))
                                formPropertyOptionsList
{
    pin = 1
    mixin="com.lsfusion.lang.psi.declarations.impl.LSFPropertyDrawMappedDeclarationImpl"
    implements="com.lsfusion.lang.psi.declarations.LSFPropertyDrawMappedDeclaration"
}

formMappedPropertiesList ::= formPropertyDrawMappedDecl (COMMA formPropertyDrawMappedDecl)* {pin = 1}

formFiltersList ::= FILTERS formExprDeclaration (COMMA formExprDeclaration)*
{
    pin(".*") = 1
    implements = "com.lsfusion.documentation.LSFDocumentation"
    methods = [getDocumentation]
}

formHintsList ::= (HINTNOUPDATE | HINTTABLE) LIST nonEmptyNoContextPropertyUsageList {pin = 1}

formEventsList ::= EVENTS formEventDeclaration (COMMA formEventDeclaration)*
{
    pin = 1
    implements = "com.lsfusion.documentation.LSFDocumentation"
    methods = [getDocumentation]
}

formEventDeclaration ::= ON
                        (    OK (BEFORE | AFTER)?
                        |    APPLY (BEFORE | AFTER)?
                        |    CLOSE
                        |    INIT
                        |    CANCEL
                        |    DROP
                        |    QUERYCLOSE
                        |    CHANGE ID
                        |    SCHEDULE PERIOD intLiteral FIXED?
                        )
                        formActionPropertyObject
{
    pin = 1
}

formFilterGroupDeclaration ::= FILTERGROUP filterGroupName regularFilterDeclaration*
{
    pin = 1
    implements = "com.lsfusion.documentation.LSFDocumentation"
    methods = [getDocumentation]
}

filterGroupName ::= simpleName
{
    mixin="com.lsfusion.lang.psi.declarations.impl.LSFFilterGroupDeclarationImpl"
    implements="com.lsfusion.lang.psi.declarations.LSFFilterGroupDeclaration"
}

formExtendFilterGroupDeclaration ::= EXTEND FILTERGROUP filterGroupUsage regularFilterDeclaration+
{
    pin(".*") = 1
    implements = "com.lsfusion.documentation.LSFDocumentation"
    methods = [getDocumentation]
}

userFiltersDeclaration ::= USERFILTERS formPropertyDrawUsage (COMMA formPropertyDrawUsage)*

filterGroupUsage ::= simpleName
{
    mixin="com.lsfusion.lang.psi.references.impl.LSFFilterGroupReferenceImpl"
    implements="com.lsfusion.lang.psi.references.LSFFilterGroupReference"
}

regularFilterDeclaration ::= FILTER localizedStringLiteral formExprDeclaration (stringLiteral)? (filterSetDefault)?

formExprDeclaration ::= propertyExpression
formActionDeclaration ::= topActionPropertyDefinitionBody
filterSetDefault ::= DEFAULT

formOrderByList ::= ORDERS FIRST? formPropertyDrawWithOrder (COMMA formPropertyDrawWithOrder)*
{
    pin(".*") = 1
    implements = "com.lsfusion.documentation.LSFDocumentation"
    methods = [getDocumentation]
}

formPivotOptionsDeclaration ::= PIVOT (
        (groupObjectUsage pivotOptions)
     |  (COLUMNS pivotPropertyDrawList (COMMA pivotPropertyDrawList)*)
     |  (ROWS pivotPropertyDrawList (COMMA pivotPropertyDrawList)*)
     |  (MEASURES formPropertyDrawUsage (COMMA formPropertyDrawUsage)*)
     )+
{
    implements = "com.lsfusion.documentation.LSFDocumentation"
    methods = [getDocumentation]
}

pivotPropertyDrawList ::= formPropertyDrawUsage | (LBRAC formPropertyDrawUsage (COMMA formPropertyDrawUsage)* RBRAC)

formPropertyDrawWithOrder ::= formPropertyDrawUsage (DESC)?

predefinedAddPropertyName ::=  NEW | NEWEDIT | EDIT

predefinedFormPropertyName ::= VALUE
                           |    INTERVAL
                           |    predefinedAddPropertyName (LSQBR explicitPropClass RSQBR)?
                           |    DELETE
{
    mixin="com.lsfusion.lang.psi.LSFIdImpl"
    implements="com.lsfusion.lang.psi.LSFId"
}

formPropertyName ::= actionOrPropertyUsage | predefinedFormPropertyName

private actionOrPropertyUsage ::= ACTION actionUsage | propertyElseActionUsage { pin(".*") = 1 }

formPropertyDrawObject ::= formPropertyName LBRAC objectUsageList RBRAC
{
//    pin = 1 // formPropertyObject before propertyExpression
    implements = "com.lsfusion.lang.psi.context.PropertyUsageContext"
    methods = [ resolveParamClasses getParamList ]
}
formPropertyObject ::= propertyUsage LBRAC objectUsageList RBRAC
{
//    pin = 1 // formPropertyObject before propertyExpression
    implements = "com.lsfusion.lang.psi.context.PropertyUsageContext"
    methods = [ resolveParamClasses getParamList ]
}
formActionObject ::= actionUsage LBRAC objectUsageList RBRAC
{
//    pin = 1 // formPropertyObject before propertyExpression
    implements = "com.lsfusion.lang.psi.context.PropertyUsageContext"
    methods = [ resolveParamClasses getParamList ]
}

aliasUsage ::= simpleName

formPropertyDrawPropertyUsage ::= simpleName

formPropertyDrawUsage ::= (<< notSimpleIdAhead >> formPropertyDrawPropertyUsage LBRAC objectUsageList RBRAC) | aliasUsage
{
    implements="com.lsfusion.lang.psi.references.LSFPropertyDrawReference"
    mixin="com.lsfusion.lang.psi.references.impl.LSFPropertyDrawReferenceImpl"
}

////////////////////////////////////////////////////////////////////////////////
/////////////////////////////OVERRIDE STATEMENT/////////////////////////////////
////////////////////////////////////////////////////////////////////////////////


overrideActionStatement ::= mappedActionClassParamDeclare PLUS
		                (WHEN propertyExpression THEN)?
		                topActionPropertyDefinitionBody OPTIMISTICASYNC?
{
//    pin = 2;
    implements="com.lsfusion.lang.psi.context.ModifyParamContext"
    methods = [ getContextModifier getContextInferrer getIcon getDocumentation]
}

overridePropertyStatement ::= mappedPropertyClassParamDeclare PLUSEQ
		                (WHEN propertyExpression THEN)?
		                propertyExpression SEMI
{
    pin = 2;
    implements="com.lsfusion.lang.psi.context.ModifyParamContext"
    methods = [ getContextModifier getContextInferrer getIcon getDocumentation]
}

////////////////////////////////////////////////////////////////////////////////
//////////////////////////////// CONSTRAINT STATEMENT //////////////////////////
////////////////////////////////////////////////////////////////////////////////

constraintStatement ::= CONSTRAINT baseEvent propertyExpression
		                (CHECKED (BY nonEmptyNoContextPropertyUsageList)? )?
		                MESSAGE messagePropertyExpression
		                (PROPERTIES nonEmptyPropertyExpressionList)?
		                SEMI
{
    pin = 1
    implements="com.lsfusion.lang.psi.context.ModifyParamContext"
    methods = [ getContextModifier getContextInferrer getIcon getDocumentation]
}

messagePropertyExpression ::= propertyExpression
{
    pin = 1
    implements="com.lsfusion.lang.psi.context.ModifyParamContext"
    methods = [ getContextModifier getContextInferrer getIcon ]
}

////////////////////////////////////////////////////////////////////////////////
///////////////////////////////// FOLLOWS STATEMENT ////////////////////////////
////////////////////////////////////////////////////////////////////////////////

followsStatement ::= mappedPropertyClassParamDeclare FOLLOWS baseEvent
                     propertyExpression (RESOLVE LEFT? RIGHT?)?		             
		             SEMI
{
    pin = 2
    implements="com.lsfusion.lang.psi.context.ModifyParamContext"
    methods = [ getContextModifier getContextInferrer getIcon getDocumentation]
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////// WRITE STATEMENT /////////////////////////////
////////////////////////////////////////////////////////////////////////////////

writeWhenStatement ::= mappedPropertyClassParamDeclare ARROW propertyExpression WHEN (DO)? propertyExpression SEMI
{
    pin = 2
    implements="com.lsfusion.lang.psi.context.ModifyParamContext"
    methods = [ getContextModifier getContextInferrer getIcon getDocumentation]
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////// EVENT STATEMENT /////////////////////////////
////////////////////////////////////////////////////////////////////////////////

eventStatement ::= WHEN baseEvent propertyExpression (ORDER (DESC)? nonEmptyPropertyExpressionList)?
		                inlineOption DO actionPropertyDefinitionBody
{
    pin = 1
    implements="com.lsfusion.lang.psi.context.ModifyParamContext"
    methods = [ getContextModifier getContextInferrer getIcon getDocumentation]
}

////////////////////////////////////////////////////////////////////////////////
//////////////////////////// GLOBAL EVENT STATEMENT ////////////////////////////
////////////////////////////////////////////////////////////////////////////////

globalEventStatement ::= ON baseEvent (SINGLE)? (SHOWDEP noContextActionOrPropertyUsage)? actionPropertyDefinitionBody
{
    pin=1
    implements="com.lsfusion.lang.psi.context.ModifyParamContext"
    methods = [ getContextModifier getContextInferrer getIcon getDocumentation]
}

baseEvent ::= (GLOBAL | LOCAL)? (FORMS nonEmptyFormUsageList)? (GOAFTER nonEmptyNoContextPropertyUsageList)?

inlineOption ::=   (NOINLINE (LBRAC exprParameterUsageList RBRAC)? )? (INLINE)?

////////////////////////////////////////////////////////////////////////////////
//////////////////////////////// SHOWDEP STATEMENT //////////////////////////////
////////////////////////////////////////////////////////////////////////////////

showDepStatement ::= SHOWDEP noContextActionOrPropertyUsage FROM noContextActionOrPropertyUsage SEMI {pin=1 methods = [ getIcon ]}

////////////////////////////////////////////////////////////////////////////////
//////////////////////////////// ASPECT STATEMENT //////////////////////////////
////////////////////////////////////////////////////////////////////////////////

aspectBefore ::= BEFORE
{
    implements="com.lsfusion.documentation.LSFDocumentation"
    methods = [getDocumentation]
}
aspectAfter ::= AFTER
{
    implements="com.lsfusion.documentation.LSFDocumentation"
    methods = [getDocumentation]
}
aspectStatement ::= (aspectBefore | aspectAfter) mappedActionClassParamDeclare DO actionPropertyDefinitionBody
{
    pin=1
    implements="com.lsfusion.lang.psi.context.ModifyParamContext"
    methods = [ getContextModifier getContextInferrer getIcon ]
}


////////////////////////////////////////////////////////////////////////////////
////////////////////////////////// TABLE STATEMENT /////////////////////////////
////////////////////////////////////////////////////////////////////////////////

noDefault ::= NODEFAULT 

tableStatement ::= TABLE simpleName LBRAC classNameList RBRAC (FULL | noDefault)? SEMI
{
    pin = 2
    mixin="com.lsfusion.lang.psi.declarations.impl.LSFTableDeclarationImpl"
    implements="com.lsfusion.lang.psi.declarations.LSFTableDeclaration"
    methods = [getDocumentation]
    stubClass = "com.lsfusion.lang.psi.stubs.TableStubElement"
    elementTypeFactory = "com.lsfusion.lang.psi.stubs.types.LSFStubElementTypeFactory.create"
}


////////////////////////////////////////////////////////////////////////////////
/////////////////////////////// LOGGABLE STATEMENT /////////////////////////////
////////////////////////////////////////////////////////////////////////////////

loggableStatement ::= LOGGABLE nonEmptyNoContextPropertyUsageList SEMI {pin=1 methods = [ getIcon ]}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////// INDEX STATEMENT /////////////////////////////
////////////////////////////////////////////////////////////////////////////////

mappedPropertyOrSimpleExprParam ::= mappedPropertyExprParam | exprParameterUsage; // exprParam
nonEmptyMappedPropertyOrSimpleExprParamList ::= mappedPropertyOrSimpleExprParam (COMMA mappedPropertyOrSimpleExprParam)*  { pin(".*") = 1}

indexStatement ::= INDEX nonEmptyMappedPropertyOrSimpleExprParamList SEMI
{
    implements="com.lsfusion.lang.psi.context.ModifyParamContext"
    methods = [ getContextModifier getContextInferrer getDocumentation]
    pin=1 methods = [ getIcon ]
}

////////////////////////////////////////////////////////////////////////////////
/////////////////////////////// WINDOW STATEMENT ////////////////////////////
////////////////////////////////////////////////////////////////////////////////

windowStatement ::= windowCreateStatement | windowHideStatement {methods = [ getIcon ]}

windowCreateStatement ::= WINDOW simpleName (localizedStringLiteral)? windowType windowOptions SEMI
{
    mixin="com.lsfusion.lang.psi.declarations.impl.LSFWindowDeclarationImpl"
    implements="com.lsfusion.lang.psi.declarations.LSFWindowDeclaration"
    methods = [getDocumentation]
    stubClass = "com.lsfusion.lang.psi.stubs.WindowStubElement"
    elementTypeFactory = "com.lsfusion.lang.psi.stubs.types.LSFStubElementTypeFactory.create"
    pin = 2
}

windowHideStatement ::= HIDE WINDOW windowUsage SEMI {pin=2}

windowType ::= MENU | PANEL | TOOLBAR | TREE

windowOptions ::=   (	HIDETITLE
                    |	DRAWROOT
                    |	HIDESCROLLBARS
                    |	orientation
                    |	dockPosition
                    |	borderPosition
                    |	HALIGN LBRAC alignmentLiteral RBRAC
                    |	VALIGN LBRAC alignmentLiteral RBRAC
                    |	TEXTHALIGN LBRAC alignmentLiteral RBRAC
                    |	TEXTVALIGN LBRAC alignmentLiteral RBRAC
                    )*

borderPosition ::= LEFT	| RIGHT | TOP | BOTTOM
orientation ::= VERTICAL | HORIZONTAL
dockPosition ::= POSITION LBRAC intLiteral COMMA intLiteral COMMA intLiteral COMMA intLiteral RBRAC

////////////////////////////////////////////////////////////////////////////////
/////////////////////////////// NAVIGATOR STATEMENT ////////////////////////////
////////////////////////////////////////////////////////////////////////////////

navigatorStatement ::= NAVIGATOR navigatorElementStatementBody
{
    pin=1
    implements = "com.lsfusion.documentation.LSFDocumentation"
    methods = [ getIcon getDocumentation]
}

navigatorElementStatementBody ::=   (   LBRACE
                                        navigatorElementBodyStatement*
                                        RBRACE
                                    ) 
                                    |   emptyStatement

navigatorElementBodyStatement ::= (     moveNavigatorElementStatement
                                  |     setupNavigatorElementStatement
                                  |     newNavigatorElementStatement
                                  |     emptyStatement
                                  |     neStub
                                  )
{
    recoverWhile = "ne_statement_recover"
}

neStub ::= NEW ID SEMI
{
    pin = 1
} 

private ne_statement_recover ::= !(MOVE | NEW | SEMI | RBRACE | ID)

moveNavigatorElementStatement ::= MOVE navigatorElementSelector (localizedStringLiteral)? navigatorElementOptions navigatorElementStatementBody
{
    pin = 1
}

newNavigatorElementStatement ::= NEW navigatorElementDescription navigatorElementOptions navigatorElementStatementBody
{
    pin = 2
    mixin="com.lsfusion.lang.psi.declarations.impl.LSFNavigatorElementDeclarationImpl"
    implements="com.lsfusion.lang.psi.declarations.LSFNavigatorElementDeclaration"
    stubClass = "com.lsfusion.lang.psi.stubs.NavigatorElementStubElement"
    elementTypeFactory = "com.lsfusion.lang.psi.stubs.types.LSFStubElementTypeFactory.create"
}

private folderElementDescription ::= FOLDER simpleName localizedStringLiteral? { pin = 2 }
simpleElementDescription ::= (simpleName? localizedStringLiteral? EQUALS)? formElseNoParamsActionUsage
navigatorElementDescription ::= (   ACTION (simpleName? localizedStringLiteral? EQUALS)? noParamsActionUsage
                                |   FORM (simpleName? localizedStringLiteral? EQUALS)? formUsage
                                |   folderElementDescription
                                |   simpleElementDescription
                                )
 
setupNavigatorElementStatement ::= navigatorElementSelector (localizedStringLiteral)? navigatorElementOptions navigatorElementStatementBody
{
    pin = 1
}

navigatorElementOptions ::= (	WINDOW windowUsage
                            |	navigatorElementInsertPosition 
                            |	IMAGE stringLiteral
                            )*

navigatorElementInsertPosition ::=	(   insertRelativePositionLiteral navigatorElementSelector
                                    |	FIRST
                                    )

navigatorElementSelector ::= navigatorElementUsage

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////// DESIGN STATEMENT ////////////////////////////
////////////////////////////////////////////////////////////////////////////////

designStatement ::=	designHeader componentBody
{
    pin = 1
    elementTypeFactory = "com.lsfusion.lang.psi.stubs.types.LSFStubElementTypeFactory.create"
    stubClass = "com.lsfusion.lang.psi.stubs.extend.DesignStubElement"
    implements="com.lsfusion.lang.psi.extend.LSFDesign, com.lsfusion.lang.psi.context.FormContext"
    mixin="com.lsfusion.lang.psi.extend.impl.LSFDesignImpl"
    methods = [ getIcon resolveFormDecl getDocumentation]
}

designHeader ::= DESIGN formUsage (localizedStringLiteral)? customFormDesignOption? {pin=2}

customFormDesignOption ::= CUSTOM

componentBody ::= componentBlockStatement | emptyStatement

componentBlockStatement ::= LBRACE componentStatement* RBRACE
{
    pin = 1
}

componentStatement ::=      setObjectPropertyStatement
                        |	setupComponentStatement
                        |	newComponentStatement
                        |   moveComponentStatement
                        |	removeComponentStatement
                        |	emptyStatement
                        |   componentStubStatement
{
    recoverWhile = "component_statement_recover"
}

private component_statement_recover ::= !component_statement_recover_start 
private component_statement_recover_start ::= ID | PARENT | PROPERTY | NEW | MOVE | REMOVE | SEMI | RBRACE | groupObjectTreeSingleSelectorType | globalSingleSelectorType | GROUP | FILTERGROUP 

componentStubStatement ::= NEW ID
{
    pin(".*") = 1
}

setupComponentStatement ::= componentSelector componentBody
{
    pin = 1
}

newComponentStatement ::= NEW componentDecl componentInsertPosition componentBody {pin = 2}
moveComponentStatement ::= MOVE componentSelector componentInsertPosition componentBody {pin = 1}

componentInsertPosition ::= (   insertRelativePositionLiteral componentSelector
                            |	FIRST
                            )?
                            
removeComponentStatement ::= REMOVE componentSelector SEMI {pin = 1}

// GROUPOBJECT + TREE
private componentSingleSelectorType ::=  BOX | OBJECTS | PANEL | TOOLBARBOX | TOOLBARLEFT | TOOLBARRIGHT | TOOLBAR
groupObjectTreeSingleSelectorType ::= componentSingleSelectorType | TOOLBARSYSTEM | FILTERGROUPS | USERFILTER | GRIDBOX | CLASSCHOOSER | GRID | FILTERBOX | FILTERS | FILTERCONTROLS
globalSingleSelectorType ::= componentSingleSelectorType 

private groupObjectTreeSelector ::= TREE treeGroupSelector | groupObjectSelector { pin(".*") = 1 }
groupSingleSelectorType ::= GROUP
private groupComponentSelector ::= groupSelector? (COMMA groupObjectTreeSelector)? { pin(".*") = 1 }

private pinnedGroupObjectTreeSelector ::= groupObjectTreeSingleSelectorType LBRAC groupObjectTreeSelector RBRAC {pin = 2}

// should match component_statement_recover
componentSelector ::=   PARENT LBRAC componentSelector RBRAC
                	|	PROPERTY LBRAC propertySelector RBRAC
                	|	FILTER LBRAC filterPropertySelector RBRAC
                	|   FILTERGROUP LBRAC filterGroupSelector RBRAC
                	|   groupSingleSelectorType LBRAC groupComponentSelector RBRAC
                	|   pinnedGroupObjectTreeSelector // pinned для нижнего правила
                	|   globalSingleSelectorType
                    |	componentUsage
{
    pin(".*") = 1
}

componentDecl ::= simpleName
{
    implements="com.lsfusion.lang.psi.declarations.LSFComponentDeclaration"
    mixin="com.lsfusion.lang.psi.declarations.impl.LSFComponentDeclarationImpl"
}

componentUsage ::= simpleName
{
    implements="com.lsfusion.lang.psi.references.LSFComponentReference"
    mixin="com.lsfusion.lang.psi.references.impl.LSFComponentReferenceImpl"
}

propertySelector ::= formPropertyDrawUsage
filterPropertySelector ::= propertySelector
groupObjectSelector ::= groupObjectUsage
treeGroupSelector ::= treeGroupUsage
filterGroupSelector ::= filterGroupUsage 
groupSelector ::= groupUsage

setObjectPropertyStatement ::= ID EQUALS componentPropertyValue SEMI {pin = 2}

componentPropertyValue ::= //commented literals are in designCalcPropertyObject
                        //colorLiteral
                        //|	(<<noIDCheck>> localizedStringLiteral) // since there is a propertyExpression afterwards, first ID would be matched
                        //|	intLiteral
                        //|	doubleLiteral
                            dimensionLiteral
                        |	booleanLiteral
                        |	tbooleanLiteral
                        |	boundsIntLiteral
                        |	boundsDoubleLiteral
                        |   containerTypeLiteral
                        |   flexAlignmentLiteral
                        |   designCalcPropertyObject

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////// META STATEMENT //////////////////////////////
////////////////////////////////////////////////////////////////////////////////

// we'll try to make all upper innerStatement rules lazy

lazyMetaDeclStatement ::= metaDeclStatement* { lazy = true extends = "com.lsfusion.lang.psi.LSFLazyParsableElement" }

private meta_decl_statement_recover ::= !(inner_statement_start | END) // we need to recover till END to "close" the metaCodeDeclarationStatement
private metaDeclStatement ::= innerStatement { recoverWhile = "meta_decl_statement_recover" }
metaCodeDeclBody ::= lazyMetaDeclStatement*

metaCodeDeclarationStatement ::= META simpleName LBRAC metaDeclIdList? RBRAC metaCodeDeclBody END
{
    pin=2
    mixin = "com.lsfusion.lang.psi.declarations.impl.LSFMetaDeclarationImpl"
    implements = "com.lsfusion.lang.psi.declarations.LSFMetaDeclaration"
    methods = [getDocumentation]
    stubClass = "com.lsfusion.lang.psi.stubs.MetaStubElement"
    elementTypeFactory = "com.lsfusion.lang.psi.stubs.types.LSFStubElementTypeFactory.create"
}

lazyMetaStatement ::= metaStatement* { lazy = true extends = "com.lsfusion.lang.psi.LSFLazyParsableElement" }

private meta_statement_recover ::= !(inner_statement_start | metaCodeBodyRightBrace) // we need to recover till END to "close" the metaCodeBody -> metaCodeStatement
private metaStatement ::= innerStatement { recoverWhile = "meta_statement_recover" }
metaCodeBody ::= metaCodeBodyLeftBrace (lazyMetaStatement*) metaCodeBodyRightBrace

metaCodeBodyLeftBrace ::= LBRACE
metaCodeBodyRightBrace ::= RBRACE

metaCodeStatement ::= metaCodeStatementHeader metaCodeBody? metaCodeStatementSemi
{
    pin=2
    mixin="com.lsfusion.lang.psi.references.impl.LSFMetaReferenceImpl"
    implements="com.lsfusion.lang.psi.references.LSFMetaReference"
    methods=[isInline]
}

metaCodeStatementType ::= ATSIGN | ATSIGN2
metaCodeStatementHeader ::= metaCodeStatementType metacodeUsage LBRAC metaCodeIdList RBRAC
metaCodeStatementSemi ::= SEMI

metaDeclId ::=  ID
metaDeclIdList ::= metaDeclId (COMMA metaDeclId)*

metaCodeIdList ::= (metaCodeId (COMMA metaCodeId)*)?

metaCodeId ::= (PRIMITIVE_TYPE | compoundID | metaCodeLiteral)?

metaCodeLiteral ::= metaCodeStringLiteral
                | 	LEX_UINT_LITERAL
                |	LEX_UNUMERIC_LITERAL
                |	LEX_UDOUBLE_LITERAL
                |	LEX_ULONG_LITERAL
                |	LEX_LOGICAL_LITERAL
                |	LEX_T_LOGICAL_LITERAL
                |	LEX_DATE_LITERAL
                |	LEX_DATETIME_LITERAL
                |	LEX_TIME_LITERAL
                |	LEX_COLOR_LITERAL
                |	NULL

metaCodeStringLiteral ::= LEX_STRING_LITERAL
{
    mixin="com.lsfusion.lang.psi.LSFMetacodeStringValueLiteralImpl"
    implements="com.lsfusion.lang.psi.LSFMetacodeStringValueLiteral"
}

////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////// COMMON /////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

emptyStatement ::= SEMI;

mappedPropertyClassParamDeclare ::= propertyUsageWrapper LBRAC classParamDeclareList RBRAC // temporary domain logic
{
    pin = 1
    implements = "com.lsfusion.lang.psi.context.PropertyUsageContext"
    methods = [ resolveParamClasses getParamList ]
}
mappedActionClassParamDeclare ::= actionUsageWrapper LBRAC classParamDeclareList RBRAC // temporary domain logic
{
    pin = 1
    implements = "com.lsfusion.lang.psi.context.PropertyUsageContext"
    methods = [ resolveParamClasses getParamList ]
}

propertyUsageWrapper ::= propertyUsage // for usages search filter
actionUsageWrapper ::= actionUsage // for usages search filter

mappedPropertyExprParam ::= propertyUsage LBRAC exprParameterUsageList RBRAC // temporary mixed logic
{
    implements = "com.lsfusion.lang.psi.context.PropertyUsageContext"
    methods = [ resolveParamClasses getParamList]
}

simpleNameWithCaption ::= simpleName (localizedStringLiteral)?
private simpleNameOrWithCaption ::= (simpleName (localizedStringLiteral)?) | localizedStringLiteral

// local

objectUsageList ::= (nonEmptyObjectUsageList)?
nonEmptyObjectUsageList ::= objectUsage (COMMA objectUsage)*

nonEmptyGroupObjectUsageList ::= groupObjectUsage (COMMA groupObjectUsage)*

// global
nonEmptyCustomClassUsageList ::= customClassUsage (COMMA customClassUsage)*  { pin(".*") = 1}

nonEmptyModuleUsageList ::= moduleUsage (COMMA moduleUsage)* { pin(".*") = 1}

nonEmptyNamespaceUsageList ::= namespaceUsage (COMMA namespaceUsage)*  { pin(".*") = 1}

classNameList ::= (nonEmptyClassNameList)?
nonEmptyClassNameList ::= className (COMMA className)* { pin(".*") = 1}

nonEmptyNoParamsPropertyUsageList ::= noParamsPropertyUsage (COMMA noParamsPropertyUsage)*  { pin(".*") = 1}
nonEmptyNoContextPropertyUsageList ::= noContextPropertyUsage (COMMA noContextPropertyUsage)*  { pin(".*") = 1}
nonEmptyNoContextActionUsageList ::= noContextActionUsage (COMMA noContextActionUsage)*  { pin(".*") = 1}

nonEmptyFormUsageList ::= formUsage (COMMA formUsage)*  { pin(".*") = 1}

exprParameterUsageList ::= (exprParameterUsage (COMMA exprParameterUsage)*)? { pin(".*") = 1}

nonEmptyActionPDBList ::= actionPropertyDefinitionBody (COMMA actionPropertyDefinitionBody)* { pin(".*") = 1}

propertyExpressionList ::= (nonEmptyPropertyExpressionList)?
nonEmptyPropertyExpressionList ::= propertyExpression (COMMA propertyExpression)* { pin(".*") = 1}

literal ::=
        ulongLiteral
	|	uintLiteral
	|	udoubleLiteral
	|	unumericLiteral
	|	(<<noIDCheck>> localizedStringLiteral) // since there is a parameter afterwards we need to do lookahead (same as in staticObjectID)
	|	booleanLiteral
	|	tbooleanLiteral
	|	dateTimeLiteral
	|	dateLiteral
	|	timeLiteral
	|	nullLiteral
	|	staticObjectID
	|	colorLiteral
{implements = "com.lsfusion.lang.psi.context.LSFExpression" methods = [ resolveInferredValueClass inferParamClasses getValueClassNames getValuePropertyNames getDocumentation]}

builtInClassName ::= PRIMITIVE_TYPE | JSON
{
    mixin="com.lsfusion.lang.psi.LSFIdImpl"
    implements="com.lsfusion.lang.psi.LSFId"
    methods = [getDocumentation]
}

className ::= builtInClassName | customClassUsage

// local

// parameterUsage is not needed yet, there is either declaration (mappedPropertyParamDeclare), or exprUsage (exprParameterUsage) 

objectUsage ::= simpleName
{mixin="com.lsfusion.lang.psi.references.impl.LSFObjectReferenceImpl" implements="com.lsfusion.lang.psi.references.LSFObjectReference"}

groupObjectUsage ::= simpleName
{mixin="com.lsfusion.lang.psi.references.impl.LSFGroupObjectReferenceImpl" implements="com.lsfusion.lang.psi.references.LSFGroupObjectReference"}

treeGroupUsage ::= simpleName
{mixin="com.lsfusion.lang.psi.references.impl.LSFTreeGroupReferenceImpl" implements="com.lsfusion.lang.psi.references.LSFTreeGroupReference"}

exprParameterNameUsage ::= classParamDeclare
{mixin="com.lsfusion.lang.psi.references.impl.LSFExprParamReferenceImpl" implements="com.lsfusion.lang.psi.references.LSFExprParamReference"}

// can be used for param and object simultaneously, for use in exprs
exprParameterUsage ::= (DOLLAR)? exprParameterNameUsage

// global

customClassUsage ::= compoundID
{mixin="com.lsfusion.lang.psi.references.impl.LSFClassReferenceImpl" implements="com.lsfusion.lang.psi.references.LSFClassReference"}

moduleUsage ::= simpleName
{mixin="com.lsfusion.lang.psi.references.impl.LSFModuleReferenceImpl" implements="com.lsfusion.lang.psi.references.LSFModuleReference"}

namespaceUsage ::= simpleName
{mixin="com.lsfusion.lang.psi.references.impl.LSFNamespaceReferenceImpl" implements="com.lsfusion.lang.psi.references.LSFNamespaceReference"}

explicitPropClass ::= className | QUESTION 

nonEmptyExplicitPropClassList ::= explicitPropClass (COMMA explicitPropClass)*
emptyExplicitPropClassList ::= nonEmptyExplicitPropClassList?
explicitPropClassUsage ::= LSQBR emptyExplicitPropClassList RSQBR
propertyUsage ::= compoundID explicitPropClassUsage?
{mixin="com.lsfusion.lang.psi.references.impl.LSFPropReferenceImpl" implements="com.lsfusion.lang.psi.references.LSFPropReference"}

actionUsage ::= compoundID explicitPropClassUsage?
{mixin="com.lsfusion.lang.psi.references.impl.LSFActionReferenceImpl" implements="com.lsfusion.lang.psi.references.LSFActionReference"}

propertyElseActionUsage ::= compoundID explicitPropClassUsage?
{mixin="com.lsfusion.lang.psi.references.impl.LSFPropElseActionReferenceImpl" implements="com.lsfusion.lang.psi.references.LSFPropElseActionReference"}

tableUsage ::= compoundID
{mixin="com.lsfusion.lang.psi.references.impl.LSFTableReferenceImpl" implements="com.lsfusion.lang.psi.references.LSFTableReference"}

groupUsage ::= compoundID
{mixin="com.lsfusion.lang.psi.references.impl.LSFGroupReferenceImpl" implements="com.lsfusion.lang.psi.references.LSFGroupReference"}

formUsage ::= compoundID
{mixin="com.lsfusion.lang.psi.references.impl.LSFFormReferenceImpl" implements="com.lsfusion.lang.psi.references.LSFFormReference"}

formElseNoParamsActionUsage ::= compoundID
{mixin="com.lsfusion.lang.psi.references.impl.LSFFormElseNoParamsActionReferenceImpl" implements="com.lsfusion.lang.psi.references.LSFFormElseNoParamsActionReference"}

windowUsage ::= compoundID
{mixin="com.lsfusion.lang.psi.references.impl.LSFWindowReferenceImpl" implements="com.lsfusion.lang.psi.references.LSFWindowReference"}

navigatorElementUsage ::= compoundID
{mixin="com.lsfusion.lang.psi.references.impl.LSFNavigatorElementReferenceImpl" implements="com.lsfusion.lang.psi.references.LSFNavigatorElementReference"}

metacodeUsage ::= compoundID
{
    implements = "com.lsfusion.documentation.LSFDocumentation"
    methods = [getDocumentation]
}

compoundID ::= (<<innerIDStop>> namespaceUsage POINT simpleName) | simpleName

staticObjectID ::= <<fullCompoundParamDeclareStop>> <<innerIDCheck>> customClassUsage POINT simpleName
{mixin="com.lsfusion.lang.psi.references.impl.LSFStaticObjectReferenceImpl" implements="com.lsfusion.lang.psi.references.LSFStaticObjectReference"}

groupObjectID ::= <<innerIDCheck>> formUsage POINT groupObjectUsage
{
    pin = 3
    implements="com.lsfusion.lang.psi.context.FormContext"
    methods = [resolveFormDecl]
}

objectID ::= <<innerIDCheck>> formUsage POINT objectUsage
{
    pin = 3
    implements="com.lsfusion.lang.psi.context.FormContext"
    methods = [resolveFormDecl]
}

componentID ::= <<innerIDCheck>> formUsage POINT componentSelector
{
    pin = 3
    implements="com.lsfusion.lang.psi.context.FormContext"
    methods = [resolveFormDecl]
}

formPropertyDrawID ::= <<innerIDCheck>> formUsage POINT formPropertyDrawUsage
{
    pin = 3
    implements="com.lsfusion.lang.psi.context.FormContext"
    methods = [resolveFormDecl]
}

exclusiveOverrideOption ::= OVERRIDE | EXCLUSIVE
{
    implements = "com.lsfusion.documentation.LSFDocumentation"
    methods = [getDocumentation]
}

abstractExclusiveOverrideOption ::= (OVERRIDE abstractCaseAddOption? ) | EXCLUSIVE
{
    implements = "com.lsfusion.documentation.LSFDocumentation"
    methods = [getDocumentation]
}

abstractCaseAddOption ::= FIRST | LAST

colorLiteral ::= LEX_COLOR_LITERAL | (RGB LBRAC uintLiteral COMMA uintLiteral COMMA uintLiteral RBRAC)

// it's tricky here, now with ID in stringLiteral / localizedStringLiteral it's important that this rules should be after "ID" rules
stringLiteral ::= LEX_STRING_LITERAL | ID
{
    mixin="com.lsfusion.lang.psi.LSFStringValueLiteralImpl"
    implements="com.lsfusion.lang.psi.LSFStringValueLiteral"
}

localizedStringLiteral ::= LEX_STRING_LITERAL | ID
{
    mixin="com.lsfusion.lang.psi.LSFLocalizedStringValueLiteralImpl"
    implements="com.lsfusion.lang.psi.LSFLocalizedStringValueLiteral"
}
intLiteral ::= (MINUS)? uintLiteral
doubleLiteral ::= (MINUS)? unumericLiteral
dateLiteral ::= LEX_DATE_LITERAL
dateTimeLiteral ::= LEX_DATETIME_LITERAL
timeLiteral ::= LEX_TIME_LITERAL
booleanLiteral ::= LEX_LOGICAL_LITERAL
tbooleanLiteral ::= LEX_T_LOGICAL_LITERAL
udoubleLiteral ::= LEX_UDOUBLE_LITERAL
unumericLiteral ::= LEX_UNUMERIC_LITERAL
uintLiteral ::= LEX_UINT_LITERAL
ulongLiteral ::= LEX_ULONG_LITERAL
nullLiteral ::= NULL
codeLiteral ::= LEX_CODE_LITERAL

nullOption ::= NONULL

equalsSign ::= EQUALS
{
    implements = "com.lsfusion.documentation.LSFDocumentation"
    methods = [getDocumentation]
}

dimensionLiteral ::= LBRAC intLiteral COMMA intLiteral RBRAC
boundsIntLiteral ::= LBRAC intLiteral COMMA intLiteral COMMA intLiteral COMMA intLiteral RBRAC
boundsDoubleLiteral ::= LBRAC doubleLiteral COMMA doubleLiteral COMMA doubleLiteral COMMA doubleLiteral RBRAC

insertRelativePositionLiteral ::= BEFORE | AFTER

containerTypeLiteral ::=    CONTAINERV
	                    |	CONTAINERH
	                    |	COLUMNS
	                    |	TABBED
	                    |   SCROLL
	                    |	SPLITH
	                    |	SPLITV
	                    
alignmentLiteral ::= START | CENTER | END

flexAlignmentLiteral ::= START | CENTER | END | STRETCH

emailRecipientTypeLiteral ::= TO | CC | BCC

